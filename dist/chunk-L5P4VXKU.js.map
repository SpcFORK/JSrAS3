{"version":3,"sources":["../src/build.ts"],"names":["build","expression","tokens","tokenize","outputQueue","operatorStack","stackType","stateIs","stacktype","InvalExprErr","isLeftAssociative","token","operators","precedence","peek","i","shuffle","pop","push","pushPopNext","_i","p","is","typeToBe","isOperator","isNumber","isLeftParen","isRightParen","isLeftBracket","isRightBracket","isLeftBrace","isRightBrace","isString","isHexNumStr","isBinNumStr","isOctNumStr","isVector","isList","isUnknown","isEOF","isOperatorToken","isIterState","isNoState","setState","type","End","handleEncodedNumber","radix","num","pushToken","value","Token","handleBlock"],"mappings":"wHAIA,SAASA,EAAMC,EAAoB,CACjC,IAAMC,EAASC,EAASF,CAAU,EAC5BG,EAAuB,CAAC,EACxBC,EAAyB,CAAC,EAEhC,IAAIC,IACJ,IAAMC,EAAWC,GAAyBA,IAAcF,EAExD,SAASG,EAAa,EAAmB,CACvC,OAAO,IAAI,MAAM,sBAAwB,EAAI,KAAK,CAAC,GAAK,GAAG,CAC7D,CAEA,SAASC,EAAkBC,EAAuB,CAChD,OAAOC,EAAUD,EAAM,KAAoB,EAAE,gBAAkB,MACjE,CAEA,SAASE,EAAWF,EAAsB,CACxC,OAAOC,EAAUD,EAAM,KAAoB,EAAE,UAC/C,CAEA,SAASG,EAAKC,EAAI,EAAU,CAC1B,OAAOV,EAAcA,EAAc,OAASU,CAAC,CAC/C,CAEA,SAASC,EAAQL,EAAsB,CACrC,OAAON,EAAc,KAAKM,CAAK,CACjC,CAEA,SAASM,GAAyB,CAChC,OAAOZ,EAAc,IAAI,CAC3B,CAEA,SAASa,EAAKP,EAAsB,CAClC,OAAOP,EAAY,KAAKO,CAAK,CAC/B,CAEA,SAASQ,EAAYC,EAAK,EAAW,CACnC,IAAIC,EAAIJ,EAAI,EACZ,GAAII,EACF,OAAOH,EAAKG,CAAC,EAGb,MAAMZ,EAAa,CACvB,CAEA,SAASa,EAAGX,EAA6BY,EAAqB,CAC5D,OAAOZ,EAAM,OAASY,CACxB,CAEA,SAASC,EAAWb,EAAuB,CACzC,OAAOW,EAAGX,GAAyB,CACrC,CAEA,SAASc,EAASd,EAAuB,CACvC,OAAOW,EAAGX,GAAuB,CACnC,CAEA,SAASe,EAAYf,EAAuB,CAC1C,OAAOW,EAAGX,GAA0B,CACtC,CAEA,SAASgB,EAAahB,EAAuB,CAC3C,OAAOW,EAAGX,GAA2B,CACvC,CAEA,SAASiB,EAAcjB,EAAuB,CAC5C,OAAOW,EAAGX,GAA4B,CACxC,CAEA,SAASkB,EAAelB,EAAuB,CAC7C,OAAOW,EAAGX,GAA6B,CACzC,CAEA,SAASmB,EAAYnB,EAAuB,CAC1C,OAAOW,EAAGX,GAA0B,CACtC,CAEA,SAASoB,EAAapB,EAAuB,CAC3C,OAAOW,EAAGX,GAA2B,CACvC,CAEA,SAASqB,EAASrB,EAAuB,CACvC,OAAOW,EAAGX,GAAuB,CACnC,CAEA,SAASsB,EAAYtB,EAAuB,CAC1C,OAAOW,EAAGX,GAA0B,CACtC,CAEA,SAASuB,EAAYvB,EAAuB,CAC1C,OAAOW,EAAGX,IAA0B,CACtC,CAEA,SAASwB,EAAYxB,EAAuB,CAC1C,OAAOW,EAAGX,IAA0B,CACtC,CAEA,SAASyB,EAASzB,EAAuB,CACvC,OAAOW,EAAGX,IAAuB,CACnC,CAEA,SAAS0B,EAAO1B,EAAuB,CACrC,OAAOW,EAAGX,IAAqB,CACjC,CAEA,SAAS2B,EAAU3B,EAAuB,CACxC,OAAOW,EAAGX,IAAwB,CACpC,CAEA,SAAS4B,EAAM5B,EAAuB,CACpC,OAAOW,EAAGX,IAAoB,CAChC,CAEA,SAAS6B,EAAgB7B,EAA2B,CAClD,OAAON,EAAc,QACnBmB,EAAWV,EAAK,CAAC,IAEdJ,EAAkBC,CAAM,GAAKE,EAAWF,CAAM,GAAKE,EAAWC,EAAK,CAAC,GACpE,CAACJ,EAAkBC,CAAM,GAAKE,EAAWF,CAAM,EAAIE,EAAWC,EAAK,CAAC,EAE3E,CAEA,SAAS2B,GAAc,CACrB,OAAOlC,GAAwB,GAAKA,GAAwB,GAAKA,GAAsB,CACzF,CAEA,SAASmC,GAAY,CACnB,OAAOnC,GAAyB,CAClC,CAEA,SAASoC,EAASC,EAAiB,CACjCtC,EAAYsC,CACd,CAEA,SAASC,GAAM,CACb,KAAOxC,EAAc,QACnBc,EAAY,CAEhB,CAEA,SAAS2B,EAAoBnC,EAA0BoC,EAA2B,CAChF,IAAIC,EAAM,SAASrC,EAAO,MAAOoC,CAAK,EACtCE,IAA4BD,CAAG,CACjC,CAEA,SAASC,EAAUL,EAAiBM,EAAY,CAC9C,OAAOhC,EAAK,IAAIiC,EAAMP,EAAMM,CAAK,CAAC,CACpC,CAEA,SAASE,EAAYR,EAAiB,CACpC,KAAOvC,EAAc,QACnBS,EAAK,EAAE,OAAS8B,GAChBzB,EAAY,EAEdF,EAAI,CACN,CAEA,KAAOf,EAAO,QAAQ,CACpB,IAAMS,EAAQT,EAAO,MAAM,EAE3B,GAAIuB,EAASd,CAAM,EACjBO,EAAKP,CAAM,EACP+B,EAAU,GACZC,GAAyB,UAEpBX,EAASrB,CAAM,EACjB8B,EAAY,GACfE,GAAyB,EAC3BzB,EAAKP,CAAM,UAGJa,EAAWb,CAAM,EAAG,CAC3B,KAAO6B,EAAgB7B,CAAM,GAC3BQ,EAAY,EAEdH,EAAQL,CAAM,CAChB,MAESe,EAAYf,CAAM,GAAKiB,EAAcjB,CAAM,GAAKmB,EAAYnB,CAAM,EACzEK,EAAQL,CAAM,EAKPsB,EAAYtB,CAAM,EACzBmC,EAAoBnC,EAAO,EAAE,EACtBuB,EAAYvB,CAAM,EACzBmC,EAAoBnC,EAAO,CAAC,EACrBwB,EAAYxB,CAAM,EACzBmC,EAAoBnC,EAAO,CAAC,EAErBgB,EAAahB,CAAM,EAC1ByC,GAA+B,EACxBvB,EAAelB,CAAM,EAC5ByC,GAAiC,EAC1BrB,EAAapB,CAAM,EAC1ByC,GAA+B,EACxBb,EAAM5B,CAAM,GACnBkC,EAAI,CACR,CAEA,OAAOzC,CACT","sourcesContent":["import { Token, TokenType, StackType } from './cst';\nimport { operators, OperatorKey } from './operators';\nimport { tokenize } from './tokenize';\n\nfunction build(expression: string) {\n  const tokens = tokenize(expression);\n  const outputQueue: Token[] = [];\n  const operatorStack: Token[] = [];\n\n  var stackType = StackType.Unknown;\n  const stateIs = (stacktype: StackType) => stacktype === stackType;\n\n  function InvalExprErr(e?: string): Error {\n    return new Error('Invalid expression' + (e ? `: ${e}` : ''));\n  }\n\n  function isLeftAssociative(token: Token): boolean {\n    return operators[token.value as OperatorKey].associativity === 'Left';\n  }\n\n  function precedence(token: Token): number {\n    return operators[token.value as OperatorKey].precedence;\n  }\n\n  function peek(i = 1): Token {\n    return operatorStack[operatorStack.length - i];\n  }\n\n  function shuffle(token: Token): number {\n    return operatorStack.push(token);\n  }\n\n  function pop(): Token | undefined {\n    return operatorStack.pop();\n  }\n\n  function push(token: Token): number {\n    return outputQueue.push(token);\n  }\n\n  function pushPopNext(_i = 1): number {\n    let p = pop();\n    if (p)\n      return push(p);\n\n    else\n      throw InvalExprErr();\n  }\n\n  function is(token: { type: TokenType; }, typeToBe: TokenType) {\n    return token.type === typeToBe;\n  }\n\n  function isOperator(token: Token): boolean {\n    return is(token, TokenType.Operator);\n  }\n\n  function isNumber(token: Token): boolean {\n    return is(token, TokenType.Number);\n  }\n\n  function isLeftParen(token: Token): boolean {\n    return is(token, TokenType.LeftParen);\n  }\n\n  function isRightParen(token: Token): boolean {\n    return is(token, TokenType.RightParen);\n  }\n\n  function isLeftBracket(token: Token): boolean {\n    return is(token, TokenType.LeftBracket);\n  }\n\n  function isRightBracket(token: Token): boolean {\n    return is(token, TokenType.RightBracket);\n  }\n\n  function isLeftBrace(token: Token): boolean {\n    return is(token, TokenType.LeftBrace);\n  }\n\n  function isRightBrace(token: Token): boolean {\n    return is(token, TokenType.RightBrace);\n  }\n\n  function isString(token: Token): boolean {\n    return is(token, TokenType.String);\n  }\n\n  function isHexNumStr(token: Token): boolean {\n    return is(token, TokenType.HexNumStr);\n  }\n\n  function isBinNumStr(token: Token): boolean {\n    return is(token, TokenType.BinNumStr);\n  }\n\n  function isOctNumStr(token: Token): boolean {\n    return is(token, TokenType.OctNumStr);\n  }\n\n  function isVector(token: Token): boolean {\n    return is(token, TokenType.Vector);\n  }\n\n  function isList(token: Token): boolean {\n    return is(token, TokenType.List);\n  }\n\n  function isUnknown(token: Token): boolean {\n    return is(token, TokenType.Unknown);\n  }\n\n  function isEOF(token: Token): boolean {\n    return is(token, TokenType.EOF);\n  }\n\n  function isOperatorToken(token: Token): boolean | 0 {\n    return operatorStack.length &&\n      isOperator(peek()) &&\n      (\n        (isLeftAssociative(token!) && precedence(token!) <= precedence(peek())) ||\n        (!isLeftAssociative(token!) && precedence(token!) < precedence(peek()))\n      );\n  }\n\n  function isIterState() {\n    return stateIs(StackType.String) || stateIs(StackType.Vector) || stateIs(StackType.List);\n  }\n\n  function isNoState() {\n    return stateIs(StackType.Unknown);\n  }\n\n  function setState(type: StackType) {\n    stackType = type;\n  }\n\n  function End() {\n    while (operatorStack.length) {\n      pushPopNext();\n    }\n  }\n\n  function handleEncodedNumber(token: Token | undefined, radix: number | undefined) {\n    let num = parseInt(token!.value, radix);\n    pushToken(TokenType.Number, num);\n  }\n\n  function pushToken(type: TokenType, value: any) {\n    return push(new Token(type, value));\n  }\n\n  function handleBlock(type: TokenType) {\n    while (operatorStack.length &&\n      peek().type !== type) {\n      pushPopNext();\n    }\n    pop();\n  }\n\n  while (tokens.length) {\n    const token = tokens.shift();\n\n    if (isNumber(token!)) {\n      push(token!);\n      if (isNoState())\n        setState(StackType.Number);\n    }\n    else if (isString(token!)) {\n      if (!isIterState())\n        setState(StackType.String);\n      push(token!);\n    }\n\n    else if (isOperator(token!)) {\n      while (isOperatorToken(token!)) {\n        pushPopNext();\n      }\n      shuffle(token!);\n    }\n\n    else if (isLeftParen(token!) || isLeftBracket(token!) || isLeftBrace(token!)) {\n      shuffle(token!);\n    }\n\n\n    // We solve and then bind a number with this\n    else if (isHexNumStr(token!))\n      handleEncodedNumber(token, 16);\n    else if (isBinNumStr(token!))\n      handleEncodedNumber(token, 2);\n    else if (isOctNumStr(token!))\n      handleEncodedNumber(token, 8);\n\n    else if (isRightParen(token!))\n      handleBlock(TokenType.LeftParen);\n    else if (isRightBracket(token!))\n      handleBlock(TokenType.LeftBracket);\n    else if (isRightBrace(token!))\n      handleBlock(TokenType.LeftBrace);\n    else if (isEOF(token!))\n      End();\n  }\n\n  return outputQueue;\n}\n\nexport { build }"]}