{"version":3,"sources":["../src/cst.ts","../src/evaluatePostfixShunted.ts"],"sourcesContent":["enum TokenType {\n  Number,\n  Operator,\n\n  LeftParen,\n  RightParen,\n  LeftBracket,\n  RightBracket,\n  LeftBrace,\n  RightBrace,\n\n  String,\n  HexNumStr,\n  BinNumStr,\n  OctNumStr,\n\n  Vector,\n  List,\n\n  Unknown,\n  EOF\n}\n\nenum StackType {\n  Number,\n  String,\n  Vector,\n  List,\n  Unknown\n}\n\nclass Token {\n  constructor(\n    public type: TokenType,\n    public value: string\n  ) { }\n}\n\nexport { TokenType, StackType, Token }","import { Token, TokenType, StackType } from './cst';\n\nfunction evaluatePostfixShunted(postfixTokens: Token[]) {\n  const stack: any[] = [];\n\n  var stackType = StackType.Unknown;\n\n  function stateIs(stacktype: StackType) {\n    return stacktype === stackType;\n  }\n\n  function isIterState() {\n    return stateIs(StackType.String) || stateIs(StackType.Vector) || stateIs(StackType.List);\n  }\n\n  function isNoState() {\n    return stateIs(StackType.Unknown);\n  }\n\n  function setState(type: StackType) {\n    stackType = type;\n  }\n\n  function handleCase(result: any, token: Token, a: number, b: number) {\n    switch (token.value) {\n      case '+':\n        result = a + b;\n        break;\n      case '-':\n        result = a - b;\n        break;\n      case '*':\n        result = a * b;\n        break;\n      case '/':\n        result = a / b;\n        break;\n      case '^':\n        result = Math.pow(a, b);\n        break;\n      default:\n        throw new Error('Unknown operator: ' + token.value);\n    }\n    return result;\n  }\n\n  postfixTokens.forEach((token) => {\n    switch (token.type) {\n      case TokenType.Number:\n        stack.push(parseFloat(token.value));\n        break;\n\n      case TokenType.Operator:\n        const b = stack.pop()!;\n        const a = stack.pop()!;\n\n        let result = handleCase(void 0, token, a, b);\n\n        stack.push(result);\n        break;\n\n      case TokenType.String:\n        stack.push(token.value);\n        if (isNoState())\n          setState(StackType.String);\n        break;\n\n      case TokenType.EOF:\n        break;\n\n      default:\n        throw new Error('Unexpected TokenType: ' + TokenType[token.type]);\n    }\n  });\n\n  // if (stack.length !== 1) throw new Error('Invalid postfix expression');\n  return stack.pop();\n}\n\nexport { evaluatePostfixShunted }"],"mappings":"mBAAA,IAAKA,OACHA,IAAA,mBACAA,IAAA,uBAEAA,IAAA,yBACAA,IAAA,2BACAA,IAAA,6BACAA,IAAA,+BACAA,IAAA,yBACAA,IAAA,2BAEAA,IAAA,mBACAA,IAAA,yBACAA,IAAA,0BACAA,IAAA,0BAEAA,IAAA,oBACAA,IAAA,gBAEAA,IAAA,sBACAA,IAAA,cApBGA,OAAA,ICEL,SAASC,EAAuBC,EAAwB,CACtD,IAAMC,EAAe,CAAC,EAEtB,IAAIC,IAEJ,SAASC,EAAQC,EAAsB,CACrC,OAAOA,IAAcF,CACvB,CAEA,SAASG,GAAc,CACrB,OAAOF,GAAwB,GAAKA,GAAwB,GAAKA,GAAsB,CACzF,CAEA,SAASG,GAAY,CACnB,OAAOH,GAAyB,CAClC,CAEA,SAASI,EAASC,EAAiB,CACjCN,EAAYM,CACd,CAEA,SAASC,EAAWC,EAAaC,EAAc,EAAWC,EAAW,CACnE,OAAQD,EAAM,MAAO,CACnB,IAAK,IACHD,EAAS,EAAIE,EACb,MACF,IAAK,IACHF,EAAS,EAAIE,EACb,MACF,IAAK,IACHF,EAAS,EAAIE,EACb,MACF,IAAK,IACHF,EAAS,EAAIE,EACb,MACF,IAAK,IACHF,EAAS,KAAK,IAAI,EAAGE,CAAC,EACtB,MACF,QACE,MAAM,IAAI,MAAM,qBAAuBD,EAAM,KAAK,CACtD,CACA,OAAOD,CACT,CAEA,OAAAV,EAAc,QAASW,GAAU,CAC/B,OAAQA,EAAM,KAAM,CAClB,OACEV,EAAM,KAAK,WAAWU,EAAM,KAAK,CAAC,EAClC,MAEF,OACE,IAAMC,EAAIX,EAAM,IAAI,EACd,EAAIA,EAAM,IAAI,EAEhBS,EAASD,EAAW,OAAQE,EAAO,EAAGC,CAAC,EAE3CX,EAAM,KAAKS,CAAM,EACjB,MAEF,OACET,EAAM,KAAKU,EAAM,KAAK,EAClBL,EAAU,GACZC,GAAyB,EAC3B,MAEF,QACE,MAEF,QACE,MAAM,IAAI,MAAM,yBAA2BM,EAAUF,EAAM,IAAI,CAAC,CACpE,CACF,CAAC,EAGMV,EAAM,IAAI,CACnB","names":["TokenType","evaluatePostfixShunted","postfixTokens","stack","stackType","stateIs","stacktype","isIterState","isNoState","setState","type","handleCase","result","token","b","TokenType"]}