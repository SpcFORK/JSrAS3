{"version":3,"sources":["../node_modules/fast-xml-parser/src/util.js","../node_modules/fast-xml-parser/src/validator.js","../node_modules/fast-xml-parser/src/xmlparser/OptionsBuilder.js","../node_modules/fast-xml-parser/src/xmlparser/xmlNode.js","../node_modules/fast-xml-parser/src/xmlparser/DocTypeReader.js","../node_modules/strnum/strnum.js","../node_modules/fast-xml-parser/src/xmlparser/OrderedObjParser.js","../node_modules/fast-xml-parser/src/xmlparser/node2json.js","../node_modules/fast-xml-parser/src/xmlparser/XMLParser.js","../node_modules/fast-xml-parser/src/xmlbuilder/orderedJs2Xml.js","../node_modules/fast-xml-parser/src/xmlbuilder/json2xml.js","../node_modules/fast-xml-parser/src/fxp.js","../src/getRuntime.ts","../src/flash/index.ts","../src/flash/events/EventDispatcher.ts","../src/flash/system/fxcommand.ts","../src/flash/system/ApplicationDomain.ts","../src/flash/system/Capabilities.ts","../src/flash/system/IME.ts","../src/flash/system/IMEConversionMode.ts","../src/flash/system/LoaderContext.ts","../src/flash/system/MessageChannelState.ts","../src/flash/system/MessageChannel.ts","../src/flash/system/Security.ts","../src/flash/system/SecurityDomain.ts","../src/flash/system/SecurityPanel.ts","../src/flash/system/System.ts","../src/flash/system/index.ts","../src/flash/xml/index.ts","../src/index.ts"],"sourcesContent":["'use strict';\n\nconst nameStartChar = ':A-Za-z_\\\\u00C0-\\\\u00D6\\\\u00D8-\\\\u00F6\\\\u00F8-\\\\u02FF\\\\u0370-\\\\u037D\\\\u037F-\\\\u1FFF\\\\u200C-\\\\u200D\\\\u2070-\\\\u218F\\\\u2C00-\\\\u2FEF\\\\u3001-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFFD';\nconst nameChar = nameStartChar + '\\\\-.\\\\d\\\\u00B7\\\\u0300-\\\\u036F\\\\u203F-\\\\u2040';\nconst nameRegexp = '[' + nameStartChar + '][' + nameChar + ']*'\nconst regexName = new RegExp('^' + nameRegexp + '$');\n\nconst getAllMatches = function(string, regex) {\n  const matches = [];\n  let match = regex.exec(string);\n  while (match) {\n    const allmatches = [];\n    allmatches.startIndex = regex.lastIndex - match[0].length;\n    const len = match.length;\n    for (let index = 0; index < len; index++) {\n      allmatches.push(match[index]);\n    }\n    matches.push(allmatches);\n    match = regex.exec(string);\n  }\n  return matches;\n};\n\nconst isName = function(string) {\n  const match = regexName.exec(string);\n  return !(match === null || typeof match === 'undefined');\n};\n\nexports.isExist = function(v) {\n  return typeof v !== 'undefined';\n};\n\nexports.isEmptyObject = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\n/**\n * Copy all the properties of a into b.\n * @param {*} target\n * @param {*} a\n */\nexports.merge = function(target, a, arrayMode) {\n  if (a) {\n    const keys = Object.keys(a); // will return an array of own properties\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      if (arrayMode === 'strict') {\n        target[keys[i]] = [ a[keys[i]] ];\n      } else {\n        target[keys[i]] = a[keys[i]];\n      }\n    }\n  }\n};\n/* exports.merge =function (b,a){\n  return Object.assign(b,a);\n} */\n\nexports.getValue = function(v) {\n  if (exports.isExist(v)) {\n    return v;\n  } else {\n    return '';\n  }\n};\n\n// const fakeCall = function(a) {return a;};\n// const fakeCallNoReturn = function() {};\n\nexports.isName = isName;\nexports.getAllMatches = getAllMatches;\nexports.nameRegexp = nameRegexp;\n","'use strict';\n\nconst util = require('./util');\n\nconst defaultOptions = {\n  allowBooleanAttributes: false, //A tag can have attributes without any value\n  unpairedTags: []\n};\n\n//const tagsPattern = new RegExp(\"<\\\\/?([\\\\w:\\\\-_\\.]+)\\\\s*\\/?>\",\"g\");\nexports.validate = function (xmlData, options) {\n  options = Object.assign({}, defaultOptions, options);\n\n  //xmlData = xmlData.replace(/(\\r\\n|\\n|\\r)/gm,\"\");//make it single line\n  //xmlData = xmlData.replace(/(^\\s*<\\?xml.*?\\?>)/g,\"\");//Remove XML starting tag\n  //xmlData = xmlData.replace(/(<!DOCTYPE[\\s\\w\\\"\\.\\/\\-\\:]+(\\[.*\\])*\\s*>)/g,\"\");//Remove DOCTYPE\n  const tags = [];\n  let tagFound = false;\n\n  //indicates that the root tag has been closed (aka. depth 0 has been reached)\n  let reachedRoot = false;\n\n  if (xmlData[0] === '\\ufeff') {\n    // check for byte order mark (BOM)\n    xmlData = xmlData.substr(1);\n  }\n  \n  for (let i = 0; i < xmlData.length; i++) {\n\n    if (xmlData[i] === '<' && xmlData[i+1] === '?') {\n      i+=2;\n      i = readPI(xmlData,i);\n      if (i.err) return i;\n    }else if (xmlData[i] === '<') {\n      //starting of tag\n      //read until you reach to '>' avoiding any '>' in attribute value\n      let tagStartPos = i;\n      i++;\n      \n      if (xmlData[i] === '!') {\n        i = readCommentAndCDATA(xmlData, i);\n        continue;\n      } else {\n        let closingTag = false;\n        if (xmlData[i] === '/') {\n          //closing tag\n          closingTag = true;\n          i++;\n        }\n        //read tagname\n        let tagName = '';\n        for (; i < xmlData.length &&\n          xmlData[i] !== '>' &&\n          xmlData[i] !== ' ' &&\n          xmlData[i] !== '\\t' &&\n          xmlData[i] !== '\\n' &&\n          xmlData[i] !== '\\r'; i++\n        ) {\n          tagName += xmlData[i];\n        }\n        tagName = tagName.trim();\n        //console.log(tagName);\n\n        if (tagName[tagName.length - 1] === '/') {\n          //self closing tag without attributes\n          tagName = tagName.substring(0, tagName.length - 1);\n          //continue;\n          i--;\n        }\n        if (!validateTagName(tagName)) {\n          let msg;\n          if (tagName.trim().length === 0) {\n            msg = \"Invalid space after '<'.\";\n          } else {\n            msg = \"Tag '\"+tagName+\"' is an invalid name.\";\n          }\n          return getErrorObject('InvalidTag', msg, getLineNumberForPosition(xmlData, i));\n        }\n\n        const result = readAttributeStr(xmlData, i);\n        if (result === false) {\n          return getErrorObject('InvalidAttr', \"Attributes for '\"+tagName+\"' have open quote.\", getLineNumberForPosition(xmlData, i));\n        }\n        let attrStr = result.value;\n        i = result.index;\n\n        if (attrStr[attrStr.length - 1] === '/') {\n          //self closing tag\n          const attrStrStart = i - attrStr.length;\n          attrStr = attrStr.substring(0, attrStr.length - 1);\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid === true) {\n            tagFound = true;\n            //continue; //text may presents after self closing tag\n          } else {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, attrStrStart + isValid.err.line));\n          }\n        } else if (closingTag) {\n          if (!result.tagClosed) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' doesn't have proper closing.\", getLineNumberForPosition(xmlData, i));\n          } else if (attrStr.trim().length > 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' can't have attributes or invalid starting.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else if (tags.length === 0) {\n            return getErrorObject('InvalidTag', \"Closing tag '\"+tagName+\"' has not been opened.\", getLineNumberForPosition(xmlData, tagStartPos));\n          } else {\n            const otg = tags.pop();\n            if (tagName !== otg.tagName) {\n              let openPos = getLineNumberForPosition(xmlData, otg.tagStartPos);\n              return getErrorObject('InvalidTag',\n                \"Expected closing tag '\"+otg.tagName+\"' (opened in line \"+openPos.line+\", col \"+openPos.col+\") instead of closing tag '\"+tagName+\"'.\",\n                getLineNumberForPosition(xmlData, tagStartPos));\n            }\n\n            //when there are no more tags, we reached the root level.\n            if (tags.length == 0) {\n              reachedRoot = true;\n            }\n          }\n        } else {\n          const isValid = validateAttributeString(attrStr, options);\n          if (isValid !== true) {\n            //the result from the nested function returns the position of the error within the attribute\n            //in order to get the 'true' error line, we need to calculate the position where the attribute begins (i - attrStr.length) and then add the position within the attribute\n            //this gives us the absolute index in the entire xml, which we can use to find the line at last\n            return getErrorObject(isValid.err.code, isValid.err.msg, getLineNumberForPosition(xmlData, i - attrStr.length + isValid.err.line));\n          }\n\n          //if the root level has been reached before ...\n          if (reachedRoot === true) {\n            return getErrorObject('InvalidXml', 'Multiple possible root nodes found.', getLineNumberForPosition(xmlData, i));\n          } else if(options.unpairedTags.indexOf(tagName) !== -1){\n            //don't push into stack\n          } else {\n            tags.push({tagName, tagStartPos});\n          }\n          tagFound = true;\n        }\n\n        //skip tag text value\n        //It may include comments and CDATA value\n        for (i++; i < xmlData.length; i++) {\n          if (xmlData[i] === '<') {\n            if (xmlData[i + 1] === '!') {\n              //comment or CADATA\n              i++;\n              i = readCommentAndCDATA(xmlData, i);\n              continue;\n            } else if (xmlData[i+1] === '?') {\n              i = readPI(xmlData, ++i);\n              if (i.err) return i;\n            } else{\n              break;\n            }\n          } else if (xmlData[i] === '&') {\n            const afterAmp = validateAmpersand(xmlData, i);\n            if (afterAmp == -1)\n              return getErrorObject('InvalidChar', \"char '&' is not expected.\", getLineNumberForPosition(xmlData, i));\n            i = afterAmp;\n          }else{\n            if (reachedRoot === true && !isWhiteSpace(xmlData[i])) {\n              return getErrorObject('InvalidXml', \"Extra text at the end\", getLineNumberForPosition(xmlData, i));\n            }\n          }\n        } //end of reading tag text value\n        if (xmlData[i] === '<') {\n          i--;\n        }\n      }\n    } else {\n      if ( isWhiteSpace(xmlData[i])) {\n        continue;\n      }\n      return getErrorObject('InvalidChar', \"char '\"+xmlData[i]+\"' is not expected.\", getLineNumberForPosition(xmlData, i));\n    }\n  }\n\n  if (!tagFound) {\n    return getErrorObject('InvalidXml', 'Start tag expected.', 1);\n  }else if (tags.length == 1) {\n      return getErrorObject('InvalidTag', \"Unclosed tag '\"+tags[0].tagName+\"'.\", getLineNumberForPosition(xmlData, tags[0].tagStartPos));\n  }else if (tags.length > 0) {\n      return getErrorObject('InvalidXml', \"Invalid '\"+\n          JSON.stringify(tags.map(t => t.tagName), null, 4).replace(/\\r?\\n/g, '')+\n          \"' found.\", {line: 1, col: 1});\n  }\n\n  return true;\n};\n\nfunction isWhiteSpace(char){\n  return char === ' ' || char === '\\t' || char === '\\n'  || char === '\\r';\n}\n/**\n * Read Processing insstructions and skip\n * @param {*} xmlData\n * @param {*} i\n */\nfunction readPI(xmlData, i) {\n  const start = i;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] == '?' || xmlData[i] == ' ') {\n      //tagname\n      const tagname = xmlData.substr(start, i - start);\n      if (i > 5 && tagname === 'xml') {\n        return getErrorObject('InvalidXml', 'XML declaration allowed only at the start of the document.', getLineNumberForPosition(xmlData, i));\n      } else if (xmlData[i] == '?' && xmlData[i + 1] == '>') {\n        //check if valid attribut string\n        i++;\n        break;\n      } else {\n        continue;\n      }\n    }\n  }\n  return i;\n}\n\nfunction readCommentAndCDATA(xmlData, i) {\n  if (xmlData.length > i + 5 && xmlData[i + 1] === '-' && xmlData[i + 2] === '-') {\n    //comment\n    for (i += 3; i < xmlData.length; i++) {\n      if (xmlData[i] === '-' && xmlData[i + 1] === '-' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  } else if (\n    xmlData.length > i + 8 &&\n    xmlData[i + 1] === 'D' &&\n    xmlData[i + 2] === 'O' &&\n    xmlData[i + 3] === 'C' &&\n    xmlData[i + 4] === 'T' &&\n    xmlData[i + 5] === 'Y' &&\n    xmlData[i + 6] === 'P' &&\n    xmlData[i + 7] === 'E'\n  ) {\n    let angleBracketsCount = 1;\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === '<') {\n        angleBracketsCount++;\n      } else if (xmlData[i] === '>') {\n        angleBracketsCount--;\n        if (angleBracketsCount === 0) {\n          break;\n        }\n      }\n    }\n  } else if (\n    xmlData.length > i + 9 &&\n    xmlData[i + 1] === '[' &&\n    xmlData[i + 2] === 'C' &&\n    xmlData[i + 3] === 'D' &&\n    xmlData[i + 4] === 'A' &&\n    xmlData[i + 5] === 'T' &&\n    xmlData[i + 6] === 'A' &&\n    xmlData[i + 7] === '['\n  ) {\n    for (i += 8; i < xmlData.length; i++) {\n      if (xmlData[i] === ']' && xmlData[i + 1] === ']' && xmlData[i + 2] === '>') {\n        i += 2;\n        break;\n      }\n    }\n  }\n\n  return i;\n}\n\nconst doubleQuote = '\"';\nconst singleQuote = \"'\";\n\n/**\n * Keep reading xmlData until '<' is found outside the attribute value.\n * @param {string} xmlData\n * @param {number} i\n */\nfunction readAttributeStr(xmlData, i) {\n  let attrStr = '';\n  let startChar = '';\n  let tagClosed = false;\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === doubleQuote || xmlData[i] === singleQuote) {\n      if (startChar === '') {\n        startChar = xmlData[i];\n      } else if (startChar !== xmlData[i]) {\n        //if vaue is enclosed with double quote then single quotes are allowed inside the value and vice versa\n      } else {\n        startChar = '';\n      }\n    } else if (xmlData[i] === '>') {\n      if (startChar === '') {\n        tagClosed = true;\n        break;\n      }\n    }\n    attrStr += xmlData[i];\n  }\n  if (startChar !== '') {\n    return false;\n  }\n\n  return {\n    value: attrStr,\n    index: i,\n    tagClosed: tagClosed\n  };\n}\n\n/**\n * Select all the attributes whether valid or invalid.\n */\nconst validAttrStrRegxp = new RegExp('(\\\\s*)([^\\\\s=]+)(\\\\s*=)?(\\\\s*([\\'\"])(([\\\\s\\\\S])*?)\\\\5)?', 'g');\n\n//attr, =\"sd\", a=\"amit's\", a=\"sd\"b=\"saf\", ab  cd=\"\"\n\nfunction validateAttributeString(attrStr, options) {\n  //console.log(\"start:\"+attrStr+\":end\");\n\n  //if(attrStr.trim().length === 0) return true; //empty string\n\n  const matches = util.getAllMatches(attrStr, validAttrStrRegxp);\n  const attrNames = {};\n\n  for (let i = 0; i < matches.length; i++) {\n    if (matches[i][1].length === 0) {\n      //nospace before attribute name: a=\"sd\"b=\"saf\"\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' has no space in starting.\", getPositionFromMatch(matches[i]))\n    } else if (matches[i][3] !== undefined && matches[i][4] === undefined) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+matches[i][2]+\"' is without value.\", getPositionFromMatch(matches[i]));\n    } else if (matches[i][3] === undefined && !options.allowBooleanAttributes) {\n      //independent attribute: ab\n      return getErrorObject('InvalidAttr', \"boolean attribute '\"+matches[i][2]+\"' is not allowed.\", getPositionFromMatch(matches[i]));\n    }\n    /* else if(matches[i][6] === undefined){//attribute without value: ab=\n                    return { err: { code:\"InvalidAttr\",msg:\"attribute \" + matches[i][2] + \" has no value assigned.\"}};\n                } */\n    const attrName = matches[i][2];\n    if (!validateAttrName(attrName)) {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is an invalid name.\", getPositionFromMatch(matches[i]));\n    }\n    if (!attrNames.hasOwnProperty(attrName)) {\n      //check for duplicate attribute.\n      attrNames[attrName] = 1;\n    } else {\n      return getErrorObject('InvalidAttr', \"Attribute '\"+attrName+\"' is repeated.\", getPositionFromMatch(matches[i]));\n    }\n  }\n\n  return true;\n}\n\nfunction validateNumberAmpersand(xmlData, i) {\n  let re = /\\d/;\n  if (xmlData[i] === 'x') {\n    i++;\n    re = /[\\da-fA-F]/;\n  }\n  for (; i < xmlData.length; i++) {\n    if (xmlData[i] === ';')\n      return i;\n    if (!xmlData[i].match(re))\n      break;\n  }\n  return -1;\n}\n\nfunction validateAmpersand(xmlData, i) {\n  // https://www.w3.org/TR/xml/#dt-charref\n  i++;\n  if (xmlData[i] === ';')\n    return -1;\n  if (xmlData[i] === '#') {\n    i++;\n    return validateNumberAmpersand(xmlData, i);\n  }\n  let count = 0;\n  for (; i < xmlData.length; i++, count++) {\n    if (xmlData[i].match(/\\w/) && count < 20)\n      continue;\n    if (xmlData[i] === ';')\n      break;\n    return -1;\n  }\n  return i;\n}\n\nfunction getErrorObject(code, message, lineNumber) {\n  return {\n    err: {\n      code: code,\n      msg: message,\n      line: lineNumber.line || lineNumber,\n      col: lineNumber.col,\n    },\n  };\n}\n\nfunction validateAttrName(attrName) {\n  return util.isName(attrName);\n}\n\n// const startsWithXML = /^xml/i;\n\nfunction validateTagName(tagname) {\n  return util.isName(tagname) /* && !tagname.match(startsWithXML) */;\n}\n\n//this function returns the line number for the character at the given index\nfunction getLineNumberForPosition(xmlData, index) {\n  const lines = xmlData.substring(0, index).split(/\\r?\\n/);\n  return {\n    line: lines.length,\n\n    // column number is last line's length + 1, because column numbering starts at 1:\n    col: lines[lines.length - 1].length + 1\n  };\n}\n\n//this function returns the position of the first character of match within attrStr\nfunction getPositionFromMatch(match) {\n  return match.startIndex + match[1].length;\n}\n","\nconst defaultOptions = {\n    preserveOrder: false,\n    attributeNamePrefix: '@_',\n    attributesGroupName: false,\n    textNodeName: '#text',\n    ignoreAttributes: true,\n    removeNSPrefix: false, // remove NS from tag name or attribute name if true\n    allowBooleanAttributes: false, //a tag can have attributes without any value\n    //ignoreRootElement : false,\n    parseTagValue: true,\n    parseAttributeValue: false,\n    trimValues: true, //Trim string values of tag and attributes\n    cdataPropName: false,\n    numberParseOptions: {\n      hex: true,\n      leadingZeros: true,\n      eNotation: true\n    },\n    tagValueProcessor: function(tagName, val) {\n      return val;\n    },\n    attributeValueProcessor: function(attrName, val) {\n      return val;\n    },\n    stopNodes: [], //nested tags will not be parsed even for errors\n    alwaysCreateTextNode: false,\n    isArray: () => false,\n    commentPropName: false,\n    unpairedTags: [],\n    processEntities: true,\n    htmlEntities: false,\n    ignoreDeclaration: false,\n    ignorePiTags: false,\n    transformTagName: false,\n    transformAttributeName: false,\n    updateTag: function(tagName, jPath, attrs){\n      return tagName\n    },\n    // skipEmptyListItem: false\n};\n   \nconst buildOptions = function(options) {\n    return Object.assign({}, defaultOptions, options);\n};\n\nexports.buildOptions = buildOptions;\nexports.defaultOptions = defaultOptions;","'use strict';\n\nclass XmlNode{\n  constructor(tagname) {\n    this.tagname = tagname;\n    this.child = []; //nested tags, text, cdata, comments in order\n    this[\":@\"] = {}; //attributes map\n  }\n  add(key,val){\n    // this.child.push( {name : key, val: val, isCdata: isCdata });\n    if(key === \"__proto__\") key = \"#__proto__\";\n    this.child.push( {[key]: val });\n  }\n  addChild(node) {\n    if(node.tagname === \"__proto__\") node.tagname = \"#__proto__\";\n    if(node[\":@\"] && Object.keys(node[\":@\"]).length > 0){\n      this.child.push( { [node.tagname]: node.child, [\":@\"]: node[\":@\"] });\n    }else{\n      this.child.push( { [node.tagname]: node.child });\n    }\n  };\n};\n\n\nmodule.exports = XmlNode;","const util = require('../util');\n\n//TODO: handle comments\nfunction readDocType(xmlData, i){\n    \n    const entities = {};\n    if( xmlData[i + 3] === 'O' &&\n         xmlData[i + 4] === 'C' &&\n         xmlData[i + 5] === 'T' &&\n         xmlData[i + 6] === 'Y' &&\n         xmlData[i + 7] === 'P' &&\n         xmlData[i + 8] === 'E')\n    {    \n        i = i+9;\n        let angleBracketsCount = 1;\n        let hasBody = false, comment = false;\n        let exp = \"\";\n        for(;i<xmlData.length;i++){\n            if (xmlData[i] === '<' && !comment) { //Determine the tag type\n                if( hasBody && isEntity(xmlData, i)){\n                    i += 7; \n                    [entityName, val,i] = readEntityExp(xmlData,i+1);\n                    if(val.indexOf(\"&\") === -1) //Parameter entities are not supported\n                        entities[ validateEntityName(entityName) ] = {\n                            regx : RegExp( `&${entityName};`,\"g\"),\n                            val: val\n                        };\n                }\n                else if( hasBody && isElement(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isAttlist(xmlData, i))  i += 8;//Not supported\n                else if( hasBody && isNotation(xmlData, i)) i += 9;//Not supported\n                else if( isComment)                         comment = true;\n                else                                        throw new Error(\"Invalid DOCTYPE\");\n\n                angleBracketsCount++;\n                exp = \"\";\n            } else if (xmlData[i] === '>') { //Read tag content\n                if(comment){\n                    if( xmlData[i - 1] === \"-\" && xmlData[i - 2] === \"-\"){\n                        comment = false;\n                        angleBracketsCount--;\n                    }\n                }else{\n                    angleBracketsCount--;\n                }\n                if (angleBracketsCount === 0) {\n                  break;\n                }\n            }else if( xmlData[i] === '['){\n                hasBody = true;\n            }else{\n                exp += xmlData[i];\n            }\n        }\n        if(angleBracketsCount !== 0){\n            throw new Error(`Unclosed DOCTYPE`);\n        }\n    }else{\n        throw new Error(`Invalid Tag instead of DOCTYPE`);\n    }\n    return {entities, i};\n}\n\nfunction readEntityExp(xmlData,i){\n    //External entities are not supported\n    //    <!ENTITY ext SYSTEM \"http://normal-website.com\" >\n\n    //Parameter entities are not supported\n    //    <!ENTITY entityname \"&anotherElement;\">\n\n    //Internal entities are supported\n    //    <!ENTITY entityname \"replacement text\">\n    \n    //read EntityName\n    let entityName = \"\";\n    for (; i < xmlData.length && (xmlData[i] !== \"'\" && xmlData[i] !== '\"' ); i++) {\n        // if(xmlData[i] === \" \") continue;\n        // else \n        entityName += xmlData[i];\n    }\n    entityName = entityName.trim();\n    if(entityName.indexOf(\" \") !== -1) throw new Error(\"External entites are not supported\");\n\n    //read Entity Value\n    const startChar = xmlData[i++];\n    let val = \"\"\n    for (; i < xmlData.length && xmlData[i] !== startChar ; i++) {\n        val += xmlData[i];\n    }\n    return [entityName, val, i];\n}\n\nfunction isComment(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === '-' &&\n    xmlData[i+3] === '-') return true\n    return false\n}\nfunction isEntity(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'N' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'I' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'Y') return true\n    return false\n}\nfunction isElement(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'E' &&\n    xmlData[i+3] === 'L' &&\n    xmlData[i+4] === 'E' &&\n    xmlData[i+5] === 'M' &&\n    xmlData[i+6] === 'E' &&\n    xmlData[i+7] === 'N' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\n\nfunction isAttlist(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'A' &&\n    xmlData[i+3] === 'T' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'L' &&\n    xmlData[i+6] === 'I' &&\n    xmlData[i+7] === 'S' &&\n    xmlData[i+8] === 'T') return true\n    return false\n}\nfunction isNotation(xmlData, i){\n    if(xmlData[i+1] === '!' &&\n    xmlData[i+2] === 'N' &&\n    xmlData[i+3] === 'O' &&\n    xmlData[i+4] === 'T' &&\n    xmlData[i+5] === 'A' &&\n    xmlData[i+6] === 'T' &&\n    xmlData[i+7] === 'I' &&\n    xmlData[i+8] === 'O' &&\n    xmlData[i+9] === 'N') return true\n    return false\n}\n\nfunction validateEntityName(name){\n    if (util.isName(name))\n\treturn name;\n    else\n        throw new Error(`Invalid entity name ${name}`);\n}\n\nmodule.exports = readDocType;\n","const hexRegex = /^[-+]?0x[a-fA-F0-9]+$/;\nconst numRegex = /^([\\-\\+])?(0*)(\\.[0-9]+([eE]\\-?[0-9]+)?|[0-9]+(\\.[0-9]+([eE]\\-?[0-9]+)?)?)$/;\n// const octRegex = /0x[a-z0-9]+/;\n// const binRegex = /0x[a-z0-9]+/;\n\n\n//polyfill\nif (!Number.parseInt && window.parseInt) {\n    Number.parseInt = window.parseInt;\n}\nif (!Number.parseFloat && window.parseFloat) {\n    Number.parseFloat = window.parseFloat;\n}\n\n  \nconst consider = {\n    hex :  true,\n    leadingZeros: true,\n    decimalPoint: \"\\.\",\n    eNotation: true\n    //skipLike: /regex/\n};\n\nfunction toNumber(str, options = {}){\n    // const options = Object.assign({}, consider);\n    // if(opt.leadingZeros === false){\n    //     options.leadingZeros = false;\n    // }else if(opt.hex === false){\n    //     options.hex = false;\n    // }\n\n    options = Object.assign({}, consider, options );\n    if(!str || typeof str !== \"string\" ) return str;\n    \n    let trimmedStr  = str.trim();\n    // if(trimmedStr === \"0.0\") return 0;\n    // else if(trimmedStr === \"+0.0\") return 0;\n    // else if(trimmedStr === \"-0.0\") return -0;\n\n    if(options.skipLike !== undefined && options.skipLike.test(trimmedStr)) return str;\n    else if (options.hex && hexRegex.test(trimmedStr)) {\n        return Number.parseInt(trimmedStr, 16);\n    // } else if (options.parseOct && octRegex.test(str)) {\n    //     return Number.parseInt(val, 8);\n    // }else if (options.parseBin && binRegex.test(str)) {\n    //     return Number.parseInt(val, 2);\n    }else{\n        //separate negative sign, leading zeros, and rest number\n        const match = numRegex.exec(trimmedStr);\n        if(match){\n            const sign = match[1];\n            const leadingZeros = match[2];\n            let numTrimmedByZeros = trimZeros(match[3]); //complete num without leading zeros\n            //trim ending zeros for floating number\n            \n            const eNotation = match[4] || match[6];\n            if(!options.leadingZeros && leadingZeros.length > 0 && sign && trimmedStr[2] !== \".\") return str; //-0123\n            else if(!options.leadingZeros && leadingZeros.length > 0 && !sign && trimmedStr[1] !== \".\") return str; //0123\n            else{//no leading zeros or leading zeros are allowed\n                const num = Number(trimmedStr);\n                const numStr = \"\" + num;\n                if(numStr.search(/[eE]/) !== -1){ //given number is long and parsed to eNotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(eNotation){ //given number has enotation\n                    if(options.eNotation) return num;\n                    else return str;\n                }else if(trimmedStr.indexOf(\".\") !== -1){ //floating number\n                    // const decimalPart = match[5].substr(1);\n                    // const intPart = trimmedStr.substr(0,trimmedStr.indexOf(\".\"));\n\n                    \n                    // const p = numStr.indexOf(\".\");\n                    // const givenIntPart = numStr.substr(0,p);\n                    // const givenDecPart = numStr.substr(p+1);\n                    if(numStr === \"0\" && (numTrimmedByZeros === \"\") ) return num; //0.0\n                    else if(numStr === numTrimmedByZeros) return num; //0.456. 0.79000\n                    else if( sign && numStr === \"-\"+numTrimmedByZeros) return num;\n                    else return str;\n                }\n                \n                if(leadingZeros){\n                    // if(numTrimmedByZeros === numStr){\n                    //     if(options.leadingZeros) return num;\n                    //     else return str;\n                    // }else return str;\n                    if(numTrimmedByZeros === numStr) return num;\n                    else if(sign+numTrimmedByZeros === numStr) return num;\n                    else return str;\n                }\n\n                if(trimmedStr === numStr) return num;\n                else if(trimmedStr === sign+numStr) return num;\n                // else{\n                //     //number with +/- sign\n                //     trimmedStr.test(/[-+][0-9]);\n\n                // }\n                return str;\n            }\n            // else if(!eNotation && trimmedStr && trimmedStr !== Number(trimmedStr) ) return str;\n            \n        }else{ //non-numeric string\n            return str;\n        }\n    }\n}\n\n/**\n * \n * @param {string} numStr without leading zeros\n * @returns \n */\nfunction trimZeros(numStr){\n    if(numStr && numStr.indexOf(\".\") !== -1){//float\n        numStr = numStr.replace(/0+$/, \"\"); //remove ending zeros\n        if(numStr === \".\")  numStr = \"0\";\n        else if(numStr[0] === \".\")  numStr = \"0\"+numStr;\n        else if(numStr[numStr.length-1] === \".\")  numStr = numStr.substr(0,numStr.length-1);\n        return numStr;\n    }\n    return numStr;\n}\nmodule.exports = toNumber\n","'use strict';\n///@ts-check\n\nconst util = require('../util');\nconst xmlNode = require('./xmlNode');\nconst readDocType = require(\"./DocTypeReader\");\nconst toNumber = require(\"strnum\");\n\n// const regx =\n//   '<((!\\\\[CDATA\\\\[([\\\\s\\\\S]*?)(]]>))|((NAME:)?(NAME))([^>]*)>|((\\\\/)(NAME)\\\\s*>))([^<]*)'\n//   .replace(/NAME/g, util.nameRegexp);\n\n//const tagsRegx = new RegExp(\"<(\\\\/?[\\\\w:\\\\-\\._]+)([^>]*)>(\\\\s*\"+cdataRegx+\")*([^<]+)?\",\"g\");\n//const tagsRegx = new RegExp(\"<(\\\\/?)((\\\\w*:)?([\\\\w:\\\\-\\._]+))([^>]*)>([^<]*)(\"+cdataRegx+\"([^<]*))*([^<]+)?\",\"g\");\n\nclass OrderedObjParser{\n  constructor(options){\n    this.options = options;\n    this.currentNode = null;\n    this.tagsNodeStack = [];\n    this.docTypeEntities = {};\n    this.lastEntities = {\n      \"apos\" : { regex: /&(apos|#39|#x27);/g, val : \"'\"},\n      \"gt\" : { regex: /&(gt|#62|#x3E);/g, val : \">\"},\n      \"lt\" : { regex: /&(lt|#60|#x3C);/g, val : \"<\"},\n      \"quot\" : { regex: /&(quot|#34|#x22);/g, val : \"\\\"\"},\n    };\n    this.ampEntity = { regex: /&(amp|#38|#x26);/g, val : \"&\"};\n    this.htmlEntities = {\n      \"space\": { regex: /&(nbsp|#160);/g, val: \" \" },\n      // \"lt\" : { regex: /&(lt|#60);/g, val: \"<\" },\n      // \"gt\" : { regex: /&(gt|#62);/g, val: \">\" },\n      // \"amp\" : { regex: /&(amp|#38);/g, val: \"&\" },\n      // \"quot\" : { regex: /&(quot|#34);/g, val: \"\\\"\" },\n      // \"apos\" : { regex: /&(apos|#39);/g, val: \"'\" },\n      \"cent\" : { regex: /&(cent|#162);/g, val: \"¢\" },\n      \"pound\" : { regex: /&(pound|#163);/g, val: \"£\" },\n      \"yen\" : { regex: /&(yen|#165);/g, val: \"¥\" },\n      \"euro\" : { regex: /&(euro|#8364);/g, val: \"€\" },\n      \"copyright\" : { regex: /&(copy|#169);/g, val: \"©\" },\n      \"reg\" : { regex: /&(reg|#174);/g, val: \"®\" },\n      \"inr\" : { regex: /&(inr|#8377);/g, val: \"₹\" },\n      \"num_dec\": { regex: /&#([0-9]{1,7});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 10)) },\n      \"num_hex\": { regex: /&#x([0-9a-fA-F]{1,6});/g, val : (_, str) => String.fromCharCode(Number.parseInt(str, 16)) },\n    };\n    this.addExternalEntities = addExternalEntities;\n    this.parseXml = parseXml;\n    this.parseTextData = parseTextData;\n    this.resolveNameSpace = resolveNameSpace;\n    this.buildAttributesMap = buildAttributesMap;\n    this.isItStopNode = isItStopNode;\n    this.replaceEntitiesValue = replaceEntitiesValue;\n    this.readStopNodeData = readStopNodeData;\n    this.saveTextToParentTag = saveTextToParentTag;\n    this.addChild = addChild;\n  }\n\n}\n\nfunction addExternalEntities(externalEntities){\n  const entKeys = Object.keys(externalEntities);\n  for (let i = 0; i < entKeys.length; i++) {\n    const ent = entKeys[i];\n    this.lastEntities[ent] = {\n       regex: new RegExp(\"&\"+ent+\";\",\"g\"),\n       val : externalEntities[ent]\n    }\n  }\n}\n\n/**\n * @param {string} val\n * @param {string} tagName\n * @param {string} jPath\n * @param {boolean} dontTrim\n * @param {boolean} hasAttributes\n * @param {boolean} isLeafNode\n * @param {boolean} escapeEntities\n */\nfunction parseTextData(val, tagName, jPath, dontTrim, hasAttributes, isLeafNode, escapeEntities) {\n  if (val !== undefined) {\n    if (this.options.trimValues && !dontTrim) {\n      val = val.trim();\n    }\n    if(val.length > 0){\n      if(!escapeEntities) val = this.replaceEntitiesValue(val);\n      \n      const newval = this.options.tagValueProcessor(tagName, val, jPath, hasAttributes, isLeafNode);\n      if(newval === null || newval === undefined){\n        //don't parse\n        return val;\n      }else if(typeof newval !== typeof val || newval !== val){\n        //overwrite\n        return newval;\n      }else if(this.options.trimValues){\n        return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n      }else{\n        const trimmedVal = val.trim();\n        if(trimmedVal === val){\n          return parseValue(val, this.options.parseTagValue, this.options.numberParseOptions);\n        }else{\n          return val;\n        }\n      }\n    }\n  }\n}\n\nfunction resolveNameSpace(tagname) {\n  if (this.options.removeNSPrefix) {\n    const tags = tagname.split(':');\n    const prefix = tagname.charAt(0) === '/' ? '/' : '';\n    if (tags[0] === 'xmlns') {\n      return '';\n    }\n    if (tags.length === 2) {\n      tagname = prefix + tags[1];\n    }\n  }\n  return tagname;\n}\n\n//TODO: change regex to capture NS\n//const attrsRegx = new RegExp(\"([\\\\w\\\\-\\\\.\\\\:]+)\\\\s*=\\\\s*(['\\\"])((.|\\n)*?)\\\\2\",\"gm\");\nconst attrsRegx = new RegExp('([^\\\\s=]+)\\\\s*(=\\\\s*([\\'\"])([\\\\s\\\\S]*?)\\\\3)?', 'gm');\n\nfunction buildAttributesMap(attrStr, jPath, tagName) {\n  if (!this.options.ignoreAttributes && typeof attrStr === 'string') {\n    // attrStr = attrStr.replace(/\\r?\\n/g, ' ');\n    //attrStr = attrStr || attrStr.trim();\n\n    const matches = util.getAllMatches(attrStr, attrsRegx);\n    const len = matches.length; //don't make it inline\n    const attrs = {};\n    for (let i = 0; i < len; i++) {\n      const attrName = this.resolveNameSpace(matches[i][1]);\n      let oldVal = matches[i][4];\n      let aName = this.options.attributeNamePrefix + attrName;\n      if (attrName.length) {\n        if (this.options.transformAttributeName) {\n          aName = this.options.transformAttributeName(aName);\n        }\n        if(aName === \"__proto__\") aName  = \"#__proto__\";\n        if (oldVal !== undefined) {\n          if (this.options.trimValues) {\n            oldVal = oldVal.trim();\n          }\n          oldVal = this.replaceEntitiesValue(oldVal);\n          const newVal = this.options.attributeValueProcessor(attrName, oldVal, jPath);\n          if(newVal === null || newVal === undefined){\n            //don't parse\n            attrs[aName] = oldVal;\n          }else if(typeof newVal !== typeof oldVal || newVal !== oldVal){\n            //overwrite\n            attrs[aName] = newVal;\n          }else{\n            //parse\n            attrs[aName] = parseValue(\n              oldVal,\n              this.options.parseAttributeValue,\n              this.options.numberParseOptions\n            );\n          }\n        } else if (this.options.allowBooleanAttributes) {\n          attrs[aName] = true;\n        }\n      }\n    }\n    if (!Object.keys(attrs).length) {\n      return;\n    }\n    if (this.options.attributesGroupName) {\n      const attrCollection = {};\n      attrCollection[this.options.attributesGroupName] = attrs;\n      return attrCollection;\n    }\n    return attrs\n  }\n}\n\nconst parseXml = function(xmlData) {\n  xmlData = xmlData.replace(/\\r\\n?/g, \"\\n\"); //TODO: remove this line\n  const xmlObj = new xmlNode('!xml');\n  let currentNode = xmlObj;\n  let textData = \"\";\n  let jPath = \"\";\n  for(let i=0; i< xmlData.length; i++){//for each char in XML data\n    const ch = xmlData[i];\n    if(ch === '<'){\n      // const nextIndex = i+1;\n      // const _2ndChar = xmlData[nextIndex];\n      if( xmlData[i+1] === '/') {//Closing Tag\n        const closeIndex = findClosingIndex(xmlData, \">\", i, \"Closing Tag is not closed.\")\n        let tagName = xmlData.substring(i+2,closeIndex).trim();\n\n        if(this.options.removeNSPrefix){\n          const colonIndex = tagName.indexOf(\":\");\n          if(colonIndex !== -1){\n            tagName = tagName.substr(colonIndex+1);\n          }\n        }\n\n        if(this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n\n        if(currentNode){\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        }\n\n        //check if last tag of nested tag was unpaired tag\n        const lastTagName = jPath.substring(jPath.lastIndexOf(\".\")+1);\n        if(tagName && this.options.unpairedTags.indexOf(tagName) !== -1 ){\n          throw new Error(`Unpaired tag can not be used as closing tag: </${tagName}>`);\n        }\n        let propIndex = 0\n        if(lastTagName && this.options.unpairedTags.indexOf(lastTagName) !== -1 ){\n          propIndex = jPath.lastIndexOf('.', jPath.lastIndexOf('.')-1)\n          this.tagsNodeStack.pop();\n        }else{\n          propIndex = jPath.lastIndexOf(\".\");\n        }\n        jPath = jPath.substring(0, propIndex);\n\n        currentNode = this.tagsNodeStack.pop();//avoid recursion, set the parent tag scope\n        textData = \"\";\n        i = closeIndex;\n      } else if( xmlData[i+1] === '?') {\n\n        let tagData = readTagExp(xmlData,i, false, \"?>\");\n        if(!tagData) throw new Error(\"Pi Tag is not closed.\");\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n        if( (this.options.ignoreDeclaration && tagData.tagName === \"?xml\") || this.options.ignorePiTags){\n\n        }else{\n  \n          const childNode = new xmlNode(tagData.tagName);\n          childNode.add(this.options.textNodeName, \"\");\n          \n          if(tagData.tagName !== tagData.tagExp && tagData.attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagData.tagExp, jPath, tagData.tagName);\n          }\n          this.addChild(currentNode, childNode, jPath)\n\n        }\n\n\n        i = tagData.closeIndex + 1;\n      } else if(xmlData.substr(i + 1, 3) === '!--') {\n        const endIndex = findClosingIndex(xmlData, \"-->\", i+4, \"Comment is not closed.\")\n        if(this.options.commentPropName){\n          const comment = xmlData.substring(i + 4, endIndex - 2);\n\n          textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n          currentNode.add(this.options.commentPropName, [ { [this.options.textNodeName] : comment } ]);\n        }\n        i = endIndex;\n      } else if( xmlData.substr(i + 1, 2) === '!D') {\n        const result = readDocType(xmlData, i);\n        this.docTypeEntities = result.entities;\n        i = result.i;\n      }else if(xmlData.substr(i + 1, 2) === '![') {\n        const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"CDATA is not closed.\") - 2;\n        const tagExp = xmlData.substring(i + 9,closeIndex);\n\n        textData = this.saveTextToParentTag(textData, currentNode, jPath);\n\n        let val = this.parseTextData(tagExp, currentNode.tagname, jPath, true, false, true, true);\n        if(val == undefined) val = \"\";\n\n        //cdata should be set even if it is 0 length string\n        if(this.options.cdataPropName){\n          currentNode.add(this.options.cdataPropName, [ { [this.options.textNodeName] : tagExp } ]);\n        }else{\n          currentNode.add(this.options.textNodeName, val);\n        }\n        \n        i = closeIndex + 2;\n      }else {//Opening tag\n        let result = readTagExp(xmlData,i, this.options.removeNSPrefix);\n        let tagName= result.tagName;\n        const rawTagName = result.rawTagName;\n        let tagExp = result.tagExp;\n        let attrExpPresent = result.attrExpPresent;\n        let closeIndex = result.closeIndex;\n\n        if (this.options.transformTagName) {\n          tagName = this.options.transformTagName(tagName);\n        }\n        \n        //save text as child node\n        if (currentNode && textData) {\n          if(currentNode.tagname !== '!xml'){\n            //when nested tag is found\n            textData = this.saveTextToParentTag(textData, currentNode, jPath, false);\n          }\n        }\n\n        //check if last tag was unpaired tag\n        const lastTag = currentNode;\n        if(lastTag && this.options.unpairedTags.indexOf(lastTag.tagname) !== -1 ){\n          currentNode = this.tagsNodeStack.pop();\n          jPath = jPath.substring(0, jPath.lastIndexOf(\".\"));\n        }\n        if(tagName !== xmlObj.tagname){\n          jPath += jPath ? \".\" + tagName : tagName;\n        }\n        if (this.isItStopNode(this.options.stopNodes, jPath, tagName)) {\n          let tagContent = \"\";\n          //self-closing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            i = result.closeIndex;\n          }\n          //unpaired tag\n          else if(this.options.unpairedTags.indexOf(tagName) !== -1){\n            \n            i = result.closeIndex;\n          }\n          //normal tag\n          else{\n            //read until closing tag is found\n            const result = this.readStopNodeData(xmlData, rawTagName, closeIndex + 1);\n            if(!result) throw new Error(`Unexpected end of ${rawTagName}`);\n            i = result.i;\n            tagContent = result.tagContent;\n          }\n\n          const childNode = new xmlNode(tagName);\n          if(tagName !== tagExp && attrExpPresent){\n            childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n          }\n          if(tagContent) {\n            tagContent = this.parseTextData(tagContent, tagName, jPath, true, attrExpPresent, true, true);\n          }\n          \n          jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          childNode.add(this.options.textNodeName, tagContent);\n          \n          this.addChild(currentNode, childNode, jPath)\n        }else{\n  //selfClosing tag\n          if(tagExp.length > 0 && tagExp.lastIndexOf(\"/\") === tagExp.length - 1){\n            if(tagName[tagName.length - 1] === \"/\"){ //remove trailing '/'\n              tagName = tagName.substr(0, tagName.length - 1);\n              jPath = jPath.substr(0, jPath.length - 1);\n              tagExp = tagName;\n            }else{\n              tagExp = tagExp.substr(0, tagExp.length - 1);\n            }\n            \n            if(this.options.transformTagName) {\n              tagName = this.options.transformTagName(tagName);\n            }\n\n            const childNode = new xmlNode(tagName);\n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            jPath = jPath.substr(0, jPath.lastIndexOf(\".\"));\n          }\n    //opening tag\n          else{\n            const childNode = new xmlNode( tagName);\n            this.tagsNodeStack.push(currentNode);\n            \n            if(tagName !== tagExp && attrExpPresent){\n              childNode[\":@\"] = this.buildAttributesMap(tagExp, jPath, tagName);\n            }\n            this.addChild(currentNode, childNode, jPath)\n            currentNode = childNode;\n          }\n          textData = \"\";\n          i = closeIndex;\n        }\n      }\n    }else{\n      textData += xmlData[i];\n    }\n  }\n  return xmlObj.child;\n}\n\nfunction addChild(currentNode, childNode, jPath){\n  const result = this.options.updateTag(childNode.tagname, jPath, childNode[\":@\"])\n  if(result === false){\n  }else if(typeof result === \"string\"){\n    childNode.tagname = result\n    currentNode.addChild(childNode);\n  }else{\n    currentNode.addChild(childNode);\n  }\n}\n\nconst replaceEntitiesValue = function(val){\n\n  if(this.options.processEntities){\n    for(let entityName in this.docTypeEntities){\n      const entity = this.docTypeEntities[entityName];\n      val = val.replace( entity.regx, entity.val);\n    }\n    for(let entityName in this.lastEntities){\n      const entity = this.lastEntities[entityName];\n      val = val.replace( entity.regex, entity.val);\n    }\n    if(this.options.htmlEntities){\n      for(let entityName in this.htmlEntities){\n        const entity = this.htmlEntities[entityName];\n        val = val.replace( entity.regex, entity.val);\n      }\n    }\n    val = val.replace( this.ampEntity.regex, this.ampEntity.val);\n  }\n  return val;\n}\nfunction saveTextToParentTag(textData, currentNode, jPath, isLeafNode) {\n  if (textData) { //store previously collected data as textNode\n    if(isLeafNode === undefined) isLeafNode = Object.keys(currentNode.child).length === 0\n    \n    textData = this.parseTextData(textData,\n      currentNode.tagname,\n      jPath,\n      false,\n      currentNode[\":@\"] ? Object.keys(currentNode[\":@\"]).length !== 0 : false,\n      isLeafNode);\n\n    if (textData !== undefined && textData !== \"\")\n      currentNode.add(this.options.textNodeName, textData);\n    textData = \"\";\n  }\n  return textData;\n}\n\n//TODO: use jPath to simplify the logic\n/**\n * \n * @param {string[]} stopNodes \n * @param {string} jPath\n * @param {string} currentTagName \n */\nfunction isItStopNode(stopNodes, jPath, currentTagName){\n  const allNodesExp = \"*.\" + currentTagName;\n  for (const stopNodePath in stopNodes) {\n    const stopNodeExp = stopNodes[stopNodePath];\n    if( allNodesExp === stopNodeExp || jPath === stopNodeExp  ) return true;\n  }\n  return false;\n}\n\n/**\n * Returns the tag Expression and where it is ending handling single-double quotes situation\n * @param {string} xmlData \n * @param {number} i starting index\n * @returns \n */\nfunction tagExpWithClosingIndex(xmlData, i, closingChar = \">\"){\n  let attrBoundary;\n  let tagExp = \"\";\n  for (let index = i; index < xmlData.length; index++) {\n    let ch = xmlData[index];\n    if (attrBoundary) {\n        if (ch === attrBoundary) attrBoundary = \"\";//reset\n    } else if (ch === '\"' || ch === \"'\") {\n        attrBoundary = ch;\n    } else if (ch === closingChar[0]) {\n      if(closingChar[1]){\n        if(xmlData[index + 1] === closingChar[1]){\n          return {\n            data: tagExp,\n            index: index\n          }\n        }\n      }else{\n        return {\n          data: tagExp,\n          index: index\n        }\n      }\n    } else if (ch === '\\t') {\n      ch = \" \"\n    }\n    tagExp += ch;\n  }\n}\n\nfunction findClosingIndex(xmlData, str, i, errMsg){\n  const closingIndex = xmlData.indexOf(str, i);\n  if(closingIndex === -1){\n    throw new Error(errMsg)\n  }else{\n    return closingIndex + str.length - 1;\n  }\n}\n\nfunction readTagExp(xmlData,i, removeNSPrefix, closingChar = \">\"){\n  const result = tagExpWithClosingIndex(xmlData, i+1, closingChar);\n  if(!result) return;\n  let tagExp = result.data;\n  const closeIndex = result.index;\n  const separatorIndex = tagExp.search(/\\s/);\n  let tagName = tagExp;\n  let attrExpPresent = true;\n  if(separatorIndex !== -1){//separate tag name and attributes expression\n    tagName = tagExp.substring(0, separatorIndex);\n    tagExp = tagExp.substring(separatorIndex + 1).trimStart();\n  }\n\n  const rawTagName = tagName;\n  if(removeNSPrefix){\n    const colonIndex = tagName.indexOf(\":\");\n    if(colonIndex !== -1){\n      tagName = tagName.substr(colonIndex+1);\n      attrExpPresent = tagName !== result.data.substr(colonIndex + 1);\n    }\n  }\n\n  return {\n    tagName: tagName,\n    tagExp: tagExp,\n    closeIndex: closeIndex,\n    attrExpPresent: attrExpPresent,\n    rawTagName: rawTagName,\n  }\n}\n/**\n * find paired tag for a stop node\n * @param {string} xmlData \n * @param {string} tagName \n * @param {number} i \n */\nfunction readStopNodeData(xmlData, tagName, i){\n  const startIndex = i;\n  // Starting at 1 since we already have an open tag\n  let openTagCount = 1;\n\n  for (; i < xmlData.length; i++) {\n    if( xmlData[i] === \"<\"){ \n      if (xmlData[i+1] === \"/\") {//close tag\n          const closeIndex = findClosingIndex(xmlData, \">\", i, `${tagName} is not closed`);\n          let closeTagName = xmlData.substring(i+2,closeIndex).trim();\n          if(closeTagName === tagName){\n            openTagCount--;\n            if (openTagCount === 0) {\n              return {\n                tagContent: xmlData.substring(startIndex, i),\n                i : closeIndex\n              }\n            }\n          }\n          i=closeIndex;\n        } else if(xmlData[i+1] === '?') { \n          const closeIndex = findClosingIndex(xmlData, \"?>\", i+1, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 3) === '!--') { \n          const closeIndex = findClosingIndex(xmlData, \"-->\", i+3, \"StopNode is not closed.\")\n          i=closeIndex;\n        } else if(xmlData.substr(i + 1, 2) === '![') { \n          const closeIndex = findClosingIndex(xmlData, \"]]>\", i, \"StopNode is not closed.\") - 2;\n          i=closeIndex;\n        } else {\n          const tagData = readTagExp(xmlData, i, '>')\n\n          if (tagData) {\n            const openTagName = tagData && tagData.tagName;\n            if (openTagName === tagName && tagData.tagExp[tagData.tagExp.length-1] !== \"/\") {\n              openTagCount++;\n            }\n            i=tagData.closeIndex;\n          }\n        }\n      }\n  }//end for loop\n}\n\nfunction parseValue(val, shouldParse, options) {\n  if (shouldParse && typeof val === 'string') {\n    //console.log(options)\n    const newval = val.trim();\n    if(newval === 'true' ) return true;\n    else if(newval === 'false' ) return false;\n    else return toNumber(val, options);\n  } else {\n    if (util.isExist(val)) {\n      return val;\n    } else {\n      return '';\n    }\n  }\n}\n\n\nmodule.exports = OrderedObjParser;\n","'use strict';\n\n/**\n * \n * @param {array} node \n * @param {any} options \n * @returns \n */\nfunction prettify(node, options){\n  return compress( node, options);\n}\n\n/**\n * \n * @param {array} arr \n * @param {object} options \n * @param {string} jPath \n * @returns object\n */\nfunction compress(arr, options, jPath){\n  let text;\n  const compressedObj = {};\n  for (let i = 0; i < arr.length; i++) {\n    const tagObj = arr[i];\n    const property = propName(tagObj);\n    let newJpath = \"\";\n    if(jPath === undefined) newJpath = property;\n    else newJpath = jPath + \".\" + property;\n\n    if(property === options.textNodeName){\n      if(text === undefined) text = tagObj[property];\n      else text += \"\" + tagObj[property];\n    }else if(property === undefined){\n      continue;\n    }else if(tagObj[property]){\n      \n      let val = compress(tagObj[property], options, newJpath);\n      const isLeaf = isLeafTag(val, options);\n\n      if(tagObj[\":@\"]){\n        assignAttributes( val, tagObj[\":@\"], newJpath, options);\n      }else if(Object.keys(val).length === 1 && val[options.textNodeName] !== undefined && !options.alwaysCreateTextNode){\n        val = val[options.textNodeName];\n      }else if(Object.keys(val).length === 0){\n        if(options.alwaysCreateTextNode) val[options.textNodeName] = \"\";\n        else val = \"\";\n      }\n\n      if(compressedObj[property] !== undefined && compressedObj.hasOwnProperty(property)) {\n        if(!Array.isArray(compressedObj[property])) {\n            compressedObj[property] = [ compressedObj[property] ];\n        }\n        compressedObj[property].push(val);\n      }else{\n        //TODO: if a node is not an array, then check if it should be an array\n        //also determine if it is a leaf node\n        if (options.isArray(property, newJpath, isLeaf )) {\n          compressedObj[property] = [val];\n        }else{\n          compressedObj[property] = val;\n        }\n      }\n    }\n    \n  }\n  // if(text && text.length > 0) compressedObj[options.textNodeName] = text;\n  if(typeof text === \"string\"){\n    if(text.length > 0) compressedObj[options.textNodeName] = text;\n  }else if(text !== undefined) compressedObj[options.textNodeName] = text;\n  return compressedObj;\n}\n\nfunction propName(obj){\n  const keys = Object.keys(obj);\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i];\n    if(key !== \":@\") return key;\n  }\n}\n\nfunction assignAttributes(obj, attrMap, jpath, options){\n  if (attrMap) {\n    const keys = Object.keys(attrMap);\n    const len = keys.length; //don't make it inline\n    for (let i = 0; i < len; i++) {\n      const atrrName = keys[i];\n      if (options.isArray(atrrName, jpath + \".\" + atrrName, true, true)) {\n        obj[atrrName] = [ attrMap[atrrName] ];\n      } else {\n        obj[atrrName] = attrMap[atrrName];\n      }\n    }\n  }\n}\n\nfunction isLeafTag(obj, options){\n  const { textNodeName } = options;\n  const propCount = Object.keys(obj).length;\n  \n  if (propCount === 0) {\n    return true;\n  }\n\n  if (\n    propCount === 1 &&\n    (obj[textNodeName] || typeof obj[textNodeName] === \"boolean\" || obj[textNodeName] === 0)\n  ) {\n    return true;\n  }\n\n  return false;\n}\nexports.prettify = prettify;\n","const { buildOptions} = require(\"./OptionsBuilder\");\nconst OrderedObjParser = require(\"./OrderedObjParser\");\nconst { prettify} = require(\"./node2json\");\nconst validator = require('../validator');\n\nclass XMLParser{\n    \n    constructor(options){\n        this.externalEntities = {};\n        this.options = buildOptions(options);\n        \n    }\n    /**\n     * Parse XML dats to JS object \n     * @param {string|Buffer} xmlData \n     * @param {boolean|Object} validationOption \n     */\n    parse(xmlData,validationOption){\n        if(typeof xmlData === \"string\"){\n        }else if( xmlData.toString){\n            xmlData = xmlData.toString();\n        }else{\n            throw new Error(\"XML data is accepted in String or Bytes[] form.\")\n        }\n        if( validationOption){\n            if(validationOption === true) validationOption = {}; //validate with default options\n            \n            const result = validator.validate(xmlData, validationOption);\n            if (result !== true) {\n              throw Error( `${result.err.msg}:${result.err.line}:${result.err.col}` )\n            }\n          }\n        const orderedObjParser = new OrderedObjParser(this.options);\n        orderedObjParser.addExternalEntities(this.externalEntities);\n        const orderedResult = orderedObjParser.parseXml(xmlData);\n        if(this.options.preserveOrder || orderedResult === undefined) return orderedResult;\n        else return prettify(orderedResult, this.options);\n    }\n\n    /**\n     * Add Entity which is not by default supported by this library\n     * @param {string} key \n     * @param {string} value \n     */\n    addEntity(key, value){\n        if(value.indexOf(\"&\") !== -1){\n            throw new Error(\"Entity value can't have '&'\")\n        }else if(key.indexOf(\"&\") !== -1 || key.indexOf(\";\") !== -1){\n            throw new Error(\"An entity must be set without '&' and ';'. Eg. use '#xD' for '&#xD;'\")\n        }else if(value === \"&\"){\n            throw new Error(\"An entity with value '&' is not permitted\");\n        }else{\n            this.externalEntities[key] = value;\n        }\n    }\n}\n\nmodule.exports = XMLParser;","const EOL = \"\\n\";\n\n/**\n * \n * @param {array} jArray \n * @param {any} options \n * @returns \n */\nfunction toXml(jArray, options) {\n    let indentation = \"\";\n    if (options.format && options.indentBy.length > 0) {\n        indentation = EOL;\n    }\n    return arrToStr(jArray, options, \"\", indentation);\n}\n\nfunction arrToStr(arr, options, jPath, indentation) {\n    let xmlStr = \"\";\n    let isPreviousElementTag = false;\n\n    for (let i = 0; i < arr.length; i++) {\n        const tagObj = arr[i];\n        const tagName = propName(tagObj);\n        if(tagName === undefined) continue;\n\n        let newJPath = \"\";\n        if (jPath.length === 0) newJPath = tagName\n        else newJPath = `${jPath}.${tagName}`;\n\n        if (tagName === options.textNodeName) {\n            let tagText = tagObj[tagName];\n            if (!isStopNode(newJPath, options)) {\n                tagText = options.tagValueProcessor(tagName, tagText);\n                tagText = replaceEntitiesValue(tagText, options);\n            }\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += tagText;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.cdataPropName) {\n            if (isPreviousElementTag) {\n                xmlStr += indentation;\n            }\n            xmlStr += `<![CDATA[${tagObj[tagName][0][options.textNodeName]}]]>`;\n            isPreviousElementTag = false;\n            continue;\n        } else if (tagName === options.commentPropName) {\n            xmlStr += indentation + `<!--${tagObj[tagName][0][options.textNodeName]}-->`;\n            isPreviousElementTag = true;\n            continue;\n        } else if (tagName[0] === \"?\") {\n            const attStr = attr_to_str(tagObj[\":@\"], options);\n            const tempInd = tagName === \"?xml\" ? \"\" : indentation;\n            let piTextNodeName = tagObj[tagName][0][options.textNodeName];\n            piTextNodeName = piTextNodeName.length !== 0 ? \" \" + piTextNodeName : \"\"; //remove extra spacing\n            xmlStr += tempInd + `<${tagName}${piTextNodeName}${attStr}?>`;\n            isPreviousElementTag = true;\n            continue;\n        }\n        let newIdentation = indentation;\n        if (newIdentation !== \"\") {\n            newIdentation += options.indentBy;\n        }\n        const attStr = attr_to_str(tagObj[\":@\"], options);\n        const tagStart = indentation + `<${tagName}${attStr}`;\n        const tagValue = arrToStr(tagObj[tagName], options, newJPath, newIdentation);\n        if (options.unpairedTags.indexOf(tagName) !== -1) {\n            if (options.suppressUnpairedNode) xmlStr += tagStart + \">\";\n            else xmlStr += tagStart + \"/>\";\n        } else if ((!tagValue || tagValue.length === 0) && options.suppressEmptyNode) {\n            xmlStr += tagStart + \"/>\";\n        } else if (tagValue && tagValue.endsWith(\">\")) {\n            xmlStr += tagStart + `>${tagValue}${indentation}</${tagName}>`;\n        } else {\n            xmlStr += tagStart + \">\";\n            if (tagValue && indentation !== \"\" && (tagValue.includes(\"/>\") || tagValue.includes(\"</\"))) {\n                xmlStr += indentation + options.indentBy + tagValue + indentation;\n            } else {\n                xmlStr += tagValue;\n            }\n            xmlStr += `</${tagName}>`;\n        }\n        isPreviousElementTag = true;\n    }\n\n    return xmlStr;\n}\n\nfunction propName(obj) {\n    const keys = Object.keys(obj);\n    for (let i = 0; i < keys.length; i++) {\n        const key = keys[i];\n        if(!obj.hasOwnProperty(key)) continue;\n        if (key !== \":@\") return key;\n    }\n}\n\nfunction attr_to_str(attrMap, options) {\n    let attrStr = \"\";\n    if (attrMap && !options.ignoreAttributes) {\n        for (let attr in attrMap) {\n            if(!attrMap.hasOwnProperty(attr)) continue;\n            let attrVal = options.attributeValueProcessor(attr, attrMap[attr]);\n            attrVal = replaceEntitiesValue(attrVal, options);\n            if (attrVal === true && options.suppressBooleanAttributes) {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}`;\n            } else {\n                attrStr += ` ${attr.substr(options.attributeNamePrefix.length)}=\"${attrVal}\"`;\n            }\n        }\n    }\n    return attrStr;\n}\n\nfunction isStopNode(jPath, options) {\n    jPath = jPath.substr(0, jPath.length - options.textNodeName.length - 1);\n    let tagName = jPath.substr(jPath.lastIndexOf(\".\") + 1);\n    for (let index in options.stopNodes) {\n        if (options.stopNodes[index] === jPath || options.stopNodes[index] === \"*.\" + tagName) return true;\n    }\n    return false;\n}\n\nfunction replaceEntitiesValue(textValue, options) {\n    if (textValue && textValue.length > 0 && options.processEntities) {\n        for (let i = 0; i < options.entities.length; i++) {\n            const entity = options.entities[i];\n            textValue = textValue.replace(entity.regex, entity.val);\n        }\n    }\n    return textValue;\n}\nmodule.exports = toXml;\n","'use strict';\n//parse Empty Node as self closing node\nconst buildFromOrderedJs = require('./orderedJs2Xml');\n\nconst defaultOptions = {\n  attributeNamePrefix: '@_',\n  attributesGroupName: false,\n  textNodeName: '#text',\n  ignoreAttributes: true,\n  cdataPropName: false,\n  format: false,\n  indentBy: '  ',\n  suppressEmptyNode: false,\n  suppressUnpairedNode: true,\n  suppressBooleanAttributes: true,\n  tagValueProcessor: function(key, a) {\n    return a;\n  },\n  attributeValueProcessor: function(attrName, a) {\n    return a;\n  },\n  preserveOrder: false,\n  commentPropName: false,\n  unpairedTags: [],\n  entities: [\n    { regex: new RegExp(\"&\", \"g\"), val: \"&amp;\" },//it must be on top\n    { regex: new RegExp(\">\", \"g\"), val: \"&gt;\" },\n    { regex: new RegExp(\"<\", \"g\"), val: \"&lt;\" },\n    { regex: new RegExp(\"\\'\", \"g\"), val: \"&apos;\" },\n    { regex: new RegExp(\"\\\"\", \"g\"), val: \"&quot;\" }\n  ],\n  processEntities: true,\n  stopNodes: [],\n  // transformTagName: false,\n  // transformAttributeName: false,\n  oneListGroup: false\n};\n\nfunction Builder(options) {\n  this.options = Object.assign({}, defaultOptions, options);\n  if (this.options.ignoreAttributes || this.options.attributesGroupName) {\n    this.isAttribute = function(/*a*/) {\n      return false;\n    };\n  } else {\n    this.attrPrefixLen = this.options.attributeNamePrefix.length;\n    this.isAttribute = isAttribute;\n  }\n\n  this.processTextOrObjNode = processTextOrObjNode\n\n  if (this.options.format) {\n    this.indentate = indentate;\n    this.tagEndChar = '>\\n';\n    this.newLine = '\\n';\n  } else {\n    this.indentate = function() {\n      return '';\n    };\n    this.tagEndChar = '>';\n    this.newLine = '';\n  }\n}\n\nBuilder.prototype.build = function(jObj) {\n  if(this.options.preserveOrder){\n    return buildFromOrderedJs(jObj, this.options);\n  }else {\n    if(Array.isArray(jObj) && this.options.arrayNodeName && this.options.arrayNodeName.length > 1){\n      jObj = {\n        [this.options.arrayNodeName] : jObj\n      }\n    }\n    return this.j2x(jObj, 0).val;\n  }\n};\n\nBuilder.prototype.j2x = function(jObj, level) {\n  let attrStr = '';\n  let val = '';\n  for (let key in jObj) {\n    if(!Object.prototype.hasOwnProperty.call(jObj, key)) continue;\n    if (typeof jObj[key] === 'undefined') {\n      // supress undefined node only if it is not an attribute\n      if (this.isAttribute(key)) {\n        val += '';\n      }\n    } else if (jObj[key] === null) {\n      // null attribute should be ignored by the attribute list, but should not cause the tag closing\n      if (this.isAttribute(key)) {\n        val += '';\n      } else if (key[0] === '?') {\n        val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n      } else {\n        val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n      }\n      // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n    } else if (jObj[key] instanceof Date) {\n      val += this.buildTextValNode(jObj[key], key, '', level);\n    } else if (typeof jObj[key] !== 'object') {\n      //premitive type\n      const attr = this.isAttribute(key);\n      if (attr) {\n        attrStr += this.buildAttrPairStr(attr, '' + jObj[key]);\n      }else {\n        //tag value\n        if (key === this.options.textNodeName) {\n          let newval = this.options.tagValueProcessor(key, '' + jObj[key]);\n          val += this.replaceEntitiesValue(newval);\n        } else {\n          val += this.buildTextValNode(jObj[key], key, '', level);\n        }\n      }\n    } else if (Array.isArray(jObj[key])) {\n      //repeated nodes\n      const arrLen = jObj[key].length;\n      let listTagVal = \"\";\n      for (let j = 0; j < arrLen; j++) {\n        const item = jObj[key][j];\n        if (typeof item === 'undefined') {\n          // supress undefined node\n        } else if (item === null) {\n          if(key[0] === \"?\") val += this.indentate(level) + '<' + key + '?' + this.tagEndChar;\n          else val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n          // val += this.indentate(level) + '<' + key + '/' + this.tagEndChar;\n        } else if (typeof item === 'object') {\n          if(this.options.oneListGroup ){\n            listTagVal += this.j2x(item, level + 1).val;\n          }else{\n            listTagVal += this.processTextOrObjNode(item, key, level)\n          }\n        } else {\n          listTagVal += this.buildTextValNode(item, key, '', level);\n        }\n      }\n      if(this.options.oneListGroup){\n        listTagVal = this.buildObjectNode(listTagVal, key, '', level);\n      }\n      val += listTagVal;\n    } else {\n      //nested node\n      if (this.options.attributesGroupName && key === this.options.attributesGroupName) {\n        const Ks = Object.keys(jObj[key]);\n        const L = Ks.length;\n        for (let j = 0; j < L; j++) {\n          attrStr += this.buildAttrPairStr(Ks[j], '' + jObj[key][Ks[j]]);\n        }\n      } else {\n        val += this.processTextOrObjNode(jObj[key], key, level)\n      }\n    }\n  }\n  return {attrStr: attrStr, val: val};\n};\n\nBuilder.prototype.buildAttrPairStr = function(attrName, val){\n  val = this.options.attributeValueProcessor(attrName, '' + val);\n  val = this.replaceEntitiesValue(val);\n  if (this.options.suppressBooleanAttributes && val === \"true\") {\n    return ' ' + attrName;\n  } else return ' ' + attrName + '=\"' + val + '\"';\n}\n\nfunction processTextOrObjNode (object, key, level) {\n  const result = this.j2x(object, level + 1);\n  if (object[this.options.textNodeName] !== undefined && Object.keys(object).length === 1) {\n    return this.buildTextValNode(object[this.options.textNodeName], key, result.attrStr, level);\n  } else {\n    return this.buildObjectNode(result.val, key, result.attrStr, level);\n  }\n}\n\nBuilder.prototype.buildObjectNode = function(val, key, attrStr, level) {\n  if(val === \"\"){\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }\n  }else{\n\n    let tagEndExp = '</' + key + this.tagEndChar;\n    let piClosingChar = \"\";\n    \n    if(key[0] === \"?\") {\n      piClosingChar = \"?\";\n      tagEndExp = \"\";\n    }\n  \n    // attrStr is an empty string in case the attribute came as undefined or null\n    if ((attrStr || attrStr === '') && val.indexOf('<') === -1) {\n      return ( this.indentate(level) + '<' +  key + attrStr + piClosingChar + '>' + val + tagEndExp );\n    } else if (this.options.commentPropName !== false && key === this.options.commentPropName && piClosingChar.length === 0) {\n      return this.indentate(level) + `<!--${val}-->` + this.newLine;\n    }else {\n      return (\n        this.indentate(level) + '<' + key + attrStr + piClosingChar + this.tagEndChar +\n        val +\n        this.indentate(level) + tagEndExp    );\n    }\n  }\n}\n\nBuilder.prototype.closeTag = function(key){\n  let closeTag = \"\";\n  if(this.options.unpairedTags.indexOf(key) !== -1){ //unpaired\n    if(!this.options.suppressUnpairedNode) closeTag = \"/\"\n  }else if(this.options.suppressEmptyNode){ //empty\n    closeTag = \"/\";\n  }else{\n    closeTag = `></${key}`\n  }\n  return closeTag;\n}\n\nfunction buildEmptyObjNode(val, key, attrStr, level) {\n  if (val !== '') {\n    return this.buildObjectNode(val, key, attrStr, level);\n  } else {\n    if(key[0] === \"?\") return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar;\n    else {\n      return  this.indentate(level) + '<' + key + attrStr + '/' + this.tagEndChar;\n      // return this.buildTagStr(level,key, attrStr);\n    }\n  }\n}\n\nBuilder.prototype.buildTextValNode = function(val, key, attrStr, level) {\n  if (this.options.cdataPropName !== false && key === this.options.cdataPropName) {\n    return this.indentate(level) + `<![CDATA[${val}]]>` +  this.newLine;\n  }else if (this.options.commentPropName !== false && key === this.options.commentPropName) {\n    return this.indentate(level) + `<!--${val}-->` +  this.newLine;\n  }else if(key[0] === \"?\") {//PI tag\n    return  this.indentate(level) + '<' + key + attrStr+ '?' + this.tagEndChar; \n  }else{\n    let textValue = this.options.tagValueProcessor(key, val);\n    textValue = this.replaceEntitiesValue(textValue);\n  \n    if( textValue === ''){\n      return this.indentate(level) + '<' + key + attrStr + this.closeTag(key) + this.tagEndChar;\n    }else{\n      return this.indentate(level) + '<' + key + attrStr + '>' +\n         textValue +\n        '</' + key + this.tagEndChar;\n    }\n  }\n}\n\nBuilder.prototype.replaceEntitiesValue = function(textValue){\n  if(textValue && textValue.length > 0 && this.options.processEntities){\n    for (let i=0; i<this.options.entities.length; i++) {\n      const entity = this.options.entities[i];\n      textValue = textValue.replace(entity.regex, entity.val);\n    }\n  }\n  return textValue;\n}\n\nfunction indentate(level) {\n  return this.options.indentBy.repeat(level);\n}\n\nfunction isAttribute(name /*, options*/) {\n  if (name.startsWith(this.options.attributeNamePrefix) && name !== this.options.textNodeName) {\n    return name.substr(this.attrPrefixLen);\n  } else {\n    return false;\n  }\n}\n\nmodule.exports = Builder;\n","'use strict';\n\nconst validator = require('./validator');\nconst XMLParser = require('./xmlparser/XMLParser');\nconst XMLBuilder = require('./xmlbuilder/json2xml');\n\nmodule.exports = {\n  XMLParser: XMLParser,\n  XMLValidator: validator,\n  XMLBuilder: XMLBuilder\n}","type Env = 'unsure' | 'web' | 'node' | 'webworker' | 'worker';\nvar Env: Env = 'unsure';\n\nlet is = (v: PropertyKey) => Reflect.has(globalThis, v)\nlet check = (v: any, m: Env) => is(v) && (Env = m);\n\n{\n  check('self', 'webworker');\n  check('WorkerGlobalScope', 'worker');\n  \n  check('module', 'node');\n  check('process', 'node');\n  \n  check('window', 'web');\n}\n\nexport default Env;","export * from './global'\n\n// export * from './accessibility'\n// export * from './concurrent'\n// export * from './crypto'\n// export * from './data'\n// export * from './desktop'\n// export * from './display'\n// export * from './display3D'\n// export * from './errors'\nexport * from './events'\n// export * from './external'\n// export * from './filesystem'\n// export * from './filters'\n// export * from './geom'\n// export * from './globalization'\n// export * from './html' // Maybe\n// export * from './media'\n// export * from './net'\n// export * from './notifications'\n// export * from './permissions'\n// export * from './printing'\n// export * from './profiler'\n// export * from './security'\n// export * from './sensors'\nexport * from './system'\n// export * from './text'\n// export * from './textLayout'\n// export * from './ui'\n// export * from './undo'\n// export * from './utils'\nexport * from './xml'","import { AST_EventDispatcher } from './global'\n\nimport { AS_EventListener } from './EventListener'\n\nexport class AS_EventDispatcher {\n\n  private listeners = new Map<string, AS_EventListener[]>\n\n  public addEventListener(type: string, listener: Function, useCapture: boolean = false, priority: number = 0, useWeakReference: boolean = false): void {\n    if (!this.listeners.has(type)) {\n      this.listeners.set(type, []);\n    }\n    const listeners = this.listeners.get(type);\n    if (listeners) {\n      const index = listeners.findIndex(item => item.priority < priority);\n      const eventListener: AS_EventListener = { priority, listener, useCapture };\n\n      if (useWeakReference) {\n        eventListener.listener = new WeakRef(listener);\n      }\n\n      if (index === -1) {\n        listeners.push(eventListener);\n      } else {\n        listeners.splice(index, 0, eventListener);\n      }\n    }\n  }\n\n  public dispatchEvent(event: Event): boolean {\n    const eventListeners = this.listeners.get(event.type);\n    if (eventListeners) {\n      for (const { listener } of eventListeners) if (!(listener instanceof WeakRef)) {\n        listener(event);\n      } else {\n        const derefListener = listener.deref();\n        if (derefListener)\n          derefListener(event);\n      }\n      return true;\n    }\n    return false;\n  }\n\n  public hasEventListener(type: string): boolean {\n    return this.listeners.has(type);\n  }\n\n  public removeEventListener(type: string, listener: Function, useCapture: boolean = false): void {\n    const eventListeners = this.listeners.get(type);\n\n    const filterListeners = (l: AS_EventListener) => {\n      if (l.listener instanceof WeakRef)\n        return l.listener.deref() !== listener;\n      return l.listener !== listener;\n    }\n\n    if (eventListeners) {\n      this.listeners.set(type, eventListeners.filter((b) => filterListeners(b)));\n    }\n  }\n\n  public willTrigger(type: string): boolean {\n    return this.hasEventListener(type);\n  }\n}","import './global';\n\n/** fscommand(command:String, args:String = \"\"):void\n *\n * Lets the SWF file communicate with either Flash Player or the program hosting Flash Player, such as a web browser. You can also use the fscommand() function to pass messages to Director or to Visual Basic, Visual C++, and other programs that can host ActiveX controls.\n *\n * The fscommand() function lets a SWF file communicate with a script in a web page. However, script access is controlled by the web page's allowScriptAccess setting. (You set this attribute in the HTML code that embeds the SWF file—for example, in the PARAM tag for Internet Explorer or the EMBED tag for Netscape.)\n *\n * When allowScriptAccess is set to \"sameDomain\" (the default), scripting is allowed only from SWF files that are in the same domain as the web page.\n * \n * When allowScriptAccess is set to \"always\", the SWF file can communicate with the HTML page in which it is embedded even when the SWF file is from a different domain than the HTML page.\n *\n * When allowScriptAccess is set to \"never\", the SWF file cannot communicate with any HTML page. Note that using this value is deprecated and not recommended, and shouldn't be necessary if you don't serve untrusted SWF files from your own domain. If you do need to serve untrusted SWF files, Adobe recommends that you create a distinct subdomain and place all untrusted content there.\n *\n * You can prevent a SWF file from using this method by setting the allowNetworking parameter of the the object and embed tags in the HTML page that contains the SWF content\n *\n * The fscommand() function is not allowed if the calling SWF file is in the local-with-file-system or local-with-network sandbox and the containing HTML page is in an untrusted sandbox\n *\n * For more information related to security, see the Flash Player Developer Center Topic: Security\n *\n * Usage 1: To use fscommand() to send a message to Flash Player, you must use predefined commands and parameters. The following table shows the values that you can specify for the fscommand() function's command and args parameters. These values control SWF files that are playing in Flash Player, including projectors. (A projector is a SWF file saved in a format that can run as a stand-alone application—that is, without Flash Player.\n *\n * Command\tParameter (args)\tPurpose\n * * quit\tNone\tCloses the projector.\n * * fullscreen\ttrue or false\tSpecifying true sets Flash Player to full-screen mode. Specifying false returns the player to normal menu view.\n * * allowscale\ttrue or false\tSpecifying false sets the player so that the SWF file is always drawn at its original size and never scaled. Specifying true forces the SWF file to scale to 100% of the player.\n * * showmenu\ttrue or false\tSpecifying true enables the full set of context menu items. Specifying false hides all of the context menu items except About Flash Player and Settings.\n * * exec\tPath to application\tExecutes an application from within the projector.\n * * trapallkeys\ttrue or false\tSpecifying true sends all key events, including accelerator keys, to the onClipEvent(keyDown/keyUp) handler in Flash Player.\n *\n * Not all of the commands listed in the table are available in all applications\n * None of the commands are available in web players.\n *\n * All of the commands are available in stand-alone projector applications.\n * AIR applications should use the flash.desktop.NativeApplication class for similar functions, such as NativeApplication.nativeApplication.exit() instead of fscommand(\"quit\").\n *\n * Ony allowscale and exec are available in test-movie players.\n * The exec command can contain only the characters A-Z, a-z, 0-9, period (.), and underscore (_). The exec command runs in the subdirectory fscommand only. In other words, if you use the exec command to call an application, the application must reside in a subdirectory named fscommand. The exec command works only from within a Flash projector file\n * sage 2: To use fscommand() to send a message to a scripting language such as JavaScript in a web browser, you can pass any two paameters in the command and args parameters. These parameters can be strings or expressions, and they are used in a JavaScript function that handles, or catches, the fscommand() function\n * \n * in a web browser, fscommand() calls the JavaScript function moviename_DoFScommand, which resides in the web page that contains the SW file. For moviename, supply the name of the Flash object that you used for the NAME attribute of the EMBED tag or the ID property o\n the OBJECT tag. If you assign the SWF file the name \"myMovie\", the JavaScript function myMovie_DoFScommand is calle\n * \n * In the web page that contains the SWF file, set the allowScriptAccess attribute to allow or deny the SWF file's ability to access th we page, as described above. (You set this attribute in the HTML code that embeds the SWF file—for example, in the PARAM tag for In\n ernet Explorer or the EMBED tag for Netscape\n * \n * In Flash Player 10 and later running in a browser, using this method programmatically to open a pop-up window may not be successful. Vaious browsers (and browser configurations) may block pop-up windows at any time; it is not possible to guarantee any po\n -up window will appear. However, for the best chance of success, use this method to open a pop-up window only in code that execute\n *as a direct result of a user action (for example, in an event handler for a mouse click or key-press event.\n * \n * Usage 3: The fscommand() function can send messages to Director (Macromedia Director from Adobe). These messages are interpreted by Lingo (the Director scripting language) as strings, events, or executable Lingo code. If a message is a string or an event, you mus wr\n t the Lingo code to receive the message from the fscommand() function and carry out an action in Director. For more information, se\n * the Director Support Center at www.adobe.com/support/director/\n * Usage 4: In VisualBasic, Visual C++, and other programs that can host ActiveX controls, fscommand() sends a VB event with two stngs that can be handled in the environment's programming language. For more information, use the keywords \"Flash method\" to search th\n Flash Support Center at www.adobe.com/support/flash\n *\n * Note: The ExternalInterface class provides better functionality for communication between JavaScript and ActionScript (Usage 2) and between ActionScript and VisualBasic, Visual C++, or other programs that can host ActiveX controls (Usage 4). You should continue to us\n fscommand() for sending messages to Flash Player (Usage 1) and Director (Usage 3\n */\nexport default function fxcommand(command: 'fullscreen' | 'allowscale' | 'showmenu' | 'exec' | 'trapallkeys' | 'quit', ...args: any[]): void {\n  if (typeof command !== 'string') {\n    throw new TypeError('command must be a string');\n  }\n\n  const formattedArgs = args.length === 0 ? [''] : args.map(arg => {\n    if (typeof arg === 'string' || typeof arg === 'number') {\n      return arg.toString();\n    }\n    throw new TypeError('args must be strings or numbers');\n  });\n\n  switch (command.toLowerCase()) {\n    case 'fullscreen':\n      document.documentElement.requestFullscreen();\n      break;\n    case 'allowscale':\n      allowScale(formattedArgs[0] === 'true')\n      break;\n    case 'quit':\n      window.close();\n      break;\n    case 'showmenu':\n      // Assuming a custom implementation of showmenu\n      toggleMenu(formattedArgs[0] === 'true');\n      break;\n    case 'exec':\n      // @ TODO\n      break;\n    case 'trapallkeys':\n      // Assuming a custom implementation of trapallkeys\n      trapAllKeys(formattedArgs[0] === 'true');\n      break;\n    default:\n      const url = new URL(window.location.href);\n      const params = new URLSearchParams(url.search);\n\n      params.set('fscommand', command);\n      params.set('fsargs', formattedArgs.join(','));\n      url.search = params.toString();\n      window.location.href = url.toString();\n      break;\n  }\n}\n\nconst gt = globalThis as any\n\nfunction allowScale(allow: boolean): void {\n  gt.AS_allowscale = allow;\n}\n\nfunction toggleMenu(show: boolean): void {\n  gt.AS_showmenu = show;\n  let ce = new CustomEvent('AS_showmenu', {\n    detail: show\n  })\n  globalThis.dispatchEvent(ce);\n}\n\nfunction trapAllKeys(trap: boolean): void {\n  gt.AS_trapallkeys = trap;\n  let ce = new CustomEvent('AS_trapallkeys', {\n    detail: trap\n  })\n}","export default class ApplicationDomain implements AST_ApplicationDomain {\n\n  /** currentDomain : ApplicationDomain\n   *\n   * [static] [read-only] Gets the current application domain in which your code is executing.\n   */\n  static readonly currentDomain: ApplicationDomain = new ApplicationDomain();\n\n  /** parentDomain : ApplicationDomain\n   *\n   * [read-only] Gets the parent domain of this application domain.\n   */\n  get parentDomain(): ApplicationDomain {\n    return this.#parentDomain;\n  }\n  #parentDomain: ApplicationDomain;\n\n  #defMap = new Map<string, any>;\n  \n  /** ApplicationDomain(parentDomain:ApplicationDomain = null)\n   *\n   * Creates a new application domain.\n   */\n  constructor(parentDomain?: ApplicationDomain, source?: string) {\n    this.#parentDomain = parentDomain || ApplicationDomain.currentDomain;\n\n    if (ApplicationDomain.currentDomain && this !== ApplicationDomain.currentDomain) {\n      this.#parentDomain.#defMap.set(source + '', this);\n    }\n    else\n      this.#parentDomain = null as any;\n  }\n\n  /** getDefinition(name:String):Object\n   *\n   * Gets a public definition from the specified application domain. The definition can be that of a class, a namespace, or a function.\n   */\n  getDefinition(name: string) {\n    return this.#defMap.get(name);\n  }\n\n  /** hasDefinition(name:String):Boolean\n   *\n   * Checks to see if a public definition exists within the specified application domain. The definition can be that of a class, a namespace, or a function.\n   */\n  hasDefinition(name: string): boolean {\n    return this.#defMap.has(name);\n  }\n}\n","export default class Capabilities implements AST_Capabilities {\n}","export default class IME implements AST_IME {\n}","export default class IMEConversionMode implements AST_IMEConversionMode {\n}","export default class LoaderContext implements AST_LoaderContext {\n}","import './global'\n\nexport default class AS_MessageChannelState implements AST_MessageChannelState {\n  /**\n   * This state indicates that the message channel has been closed and doesn't have any more messages to deliver.\n   */\n  static CLOSED: \"closed\";\n  /**\n   * This state indicates that the message channel has been instructed to close and is in the process of delivering the remaining messages on the channel.\n   */\n  static CLOSING: \"closing\";\n  /**\n   * This state indicates that the message channel is open and available\n   * for use.\n   */\n  static OPEN: \"open\";\n}","import './global'\n\nimport AS_MessageChannelState from \"./MessageChannelState\";\n\nimport { AS_EventDispatcher } from '../events'\n\nexport default class AS_MessageChannel extends AS_EventDispatcher {\n  #state: AS_MessageChannelState | undefined;\n  #buffer: ArrayBuffer | undefined;\n  #view: DataView | undefined;\n  #byteOffset: number | undefined;\n  #byteLength: number | undefined;\n  #isClosed: boolean | undefined;\n\n  constructor(buffer: ArrayBuffer, byteOffset: number, byteLength: number) {\n    super();\n    this.#initializeChannel(buffer, byteOffset, byteLength);\n  }\n\n  #initializeChannel(buffer: ArrayBuffer, byteOffset: number, byteLength: number): void {\n    this.#state = AS_MessageChannelState.OPEN;\n    this.#buffer = buffer;\n    this.#view = new DataView(buffer, byteOffset, byteLength);\n    this.#byteOffset = byteOffset;\n    this.#byteLength = byteLength;\n    this.#isClosed = false;\n  }\n\n  get state() {\n    return this.#state;\n  }\n\n  get buffer() {\n    return this.#buffer;\n  }\n\n  get view() {\n    return this.#view;\n  }\n\n  get byteOffset() {\n    return this.#byteOffset;\n  }\n\n  get byteLength() {\n    return this.#byteLength;\n  }\n\n  get isClosed() {\n    return this.#isClosed;\n  }\n}","export default class Security implements AST_Security {\n}","export default class SecurityDomain implements AST_SecurityDomain {\n}","export default class SecurityPanel implements AST_SecurityPanel {\n}","export default class System implements AST_System {\n}","import './global'\n\nimport fxcommand from './fxcommand'\n\nimport ApplicationDomain from './ApplicationDomain';\nimport Capabilities from './Capabilities';\nimport IME from './IME';\nimport IMEConversionMode from './IMEConversionMode';\n// import JPEGLoaderContext from './JPEGLoaderContext';\nimport LoaderContext from './LoaderContext';\nimport MessageChannel from './MessageChannel';\nimport MessageChannelState from './MessageChannelState';\nimport Security from './Security';\nimport SecurityDomain from './SecurityDomain';\nimport SecurityPanel from './SecurityPanel';\nimport System from './System';\n\n/**\n * The flash.system package contains classes for accessing system-level functionality, such as security, garbage collection, etc.\n */\nexport class AS_System {\n\n  /**\n   * Lets the SWF file communicate with either Flash Player or the program hosting Flash Player, such as a web browser.\n   * @unsure\n   */\n  fxcommand = fxcommand.bind(this)\n\n  /**\n   * The ApplicationDomain class is a container for discrete groups of class definitions.\n   */\n  ApplicationDomain = ApplicationDomain\n\n  /**\n   * The Capabilities class provides properties that describe the system and runtime that are hosting the application.\n   */\n  Capabilities = Capabilities;\n\n  /**\n   * The IME class lets you directly manipulate the operating system's input method editor (IME) in the Flash runtime application that is running on a client computer.\n   */\n  IME = IME;\n\n  /**\n   * This class contains constants for use with the IME.conversionMode property.\n   */\n  IMEConversionMode = IMEConversionMode;\n\n  /**\n   * The JPEGLoaderContext class is used to load JPEG images.\n   */\n  // JPEGLoaderContext = JPEGLoaderContext;\n\n  /**\n   * The LoaderContext class provides options for loading SWF files and other media by using the Loader class.\n   */\n  LoaderContext = LoaderContext;\n\n  /**\n   * The MessageChannel class is used to send messages between SWF files and the program hosting Flash Player.\n   */\n  MessageChannel = MessageChannel;\n\n  /**\n   * The MessageChannelState class contains constants that indicate the current state of the MessageChannel object.\n   */\n  MessageChannelState = MessageChannelState;\n\n  /**\n   * The Security class lets you specify how content in different domains can communicate with each other.\n   */\n  Security = Security;\n\n  /**\n   * The SecurityDomain class represents the current security \"sandbox,\" also known as a security domain.\n   */\n  SecurityDomain = SecurityDomain;\n\n  /**\n   * The SecurityPanel class provides values for specifying which Security Settings panel you want to display.\n   */\n  SecurityPanel = SecurityPanel;\n\n  /**\n   * The System class contains properties related to local settings and operations.\n   */\n  System = System;\n\n}","import runtime from '../../getRuntime';\n\n\nexport type XMLArgs = Boolean | null | Number | Object | String | undefined | AS3_XML | AS3_XMLList;\n\n\nexport type XMLNodeTypes =\n  typeof AS2_XMLNodeType.ELEMENT_NODE\n  | typeof AS2_XMLNodeType.TEXT_NODE\n\n\nexport type InternalNodeTypes = XMLNodeTypes\n  | typeof AS2_XMLNodeType.ENTITY_REFERENCE_NODE\n  | typeof AS2_XMLNodeType.PROCESSING_INSTRUCTION_NODE\n  | typeof AS2_XMLNodeType.DOCUMENT_NODE\n  | typeof AS2_XMLNodeType.DOCUMENT_FRAGMENT_NODE;\n\n\n// ---\n\n\nclass XMLModuleDefaultsClass {\n  static self = this\n  self = XMLModuleDefaultsClass\n\n  /**\n   * Determines whether XML comments are ignored when XML objects parse the source XML data.\n   * By default, the comments are ignored (true).\n   * To include XML comments, set this property to false.\n   * The ignoreComments property is used only during the XML parsing, not during the call to any method such as myXMLObject.child(*).toXMLString().\n   * If the source XML includes comment nodes, they are kept or discarded during the XML parsing.  \n  */\n  ignoreComments = true\n  /**\n   * Determines whether XML processing instructions are ignored when XML objects parse the source XML data. By default, the processing instructions are ignored (true).\n   * To include XML processing instructions, set this property to false.\n   * The ignoreProcessingInstructions property is used only during the XML parsing, not during the call to any method such as myXMLObject.child(*).toXMLString().\n   * If the source XML includes processing instructions nodes, they are kept or discarded during the XML parsing.\n  */\n  ignoreProcessingInstructions = true\n  /**\n   * Determines whether white space characters at the beginning and end of text nodes are ignored during parsing.\n   * By default, white space is ignored (true).\n   * If a text node is 100% white space and the ignoreWhitespace property is set to true, then the node is not created.\n   * To show white space in a text node, set the ignoreWhitespace property to false.\n   *\n   * When you create an XML object, it caches the current value of the ignoreWhitespace property.\n   * Changing the ignoreWhitespace does not change the behavior of existing XML objects.\n  */\n  ignoreWhitespace = true\n  /**\n   * Determines the amount of indentation applied by the toString() and toXMLString() methods when the XML.prettyPrinting property is set to true.\n   * Indentation is applied with the space character, not the tab character. The default value is 2.\n   */\n  prettyIndent = 2\n  /**\n   * Determines whether the toString() and toXMLString() methods normalize white space characters between some tags.\n   * The default value is true.\n   */\n  prettyPrinting = true\n\n  defaultSettings() {\n    return new this.self;\n  }\n}\n\n\n// ---\n\n\n/** An AS3-Standard-Like XMLNS\n * \n * The Namespace class contains methods and properties for defining and working with namespaces.\n * There are three scenarios for using namespaces:\n * * Namespaces of XML objects Namespaces associate a namespace prefix with a Uniform Resource Identifier (URI) that identifies the namespace.\n *   The prefix is a string used to reference the namespace within an XML object. If the prefix is undefined, when the XML is converted to a string, a prefix is automatically generated.\n * * Namespace to differentiate methods Namespaces can differentiate methods with the same name to perform different tasks.\n *   If two methods have the same name but separate namespaces, they can perform different tasks.\n * * Namespaces for access control Namespaces can be used to control access to a group of properties and methods in a class.\n *   If you place the properties and methods into a private namespace, they are inaccessible to any code that does not have access to that namespace.\n *   You can grant access to the group of properties and methods by passing the namespace to other classes, methods or functions.\n * This class shows two forms of the constructor method because each form accepts different parameters.\n *\n * This class (along with the XML, XMLList, and QName classes) implements powerful XML-handling standards defined in ECMAScript for XML (E4X) specification (ECMA-357 edition 2).\n */\nclass AS3_XMLNamespace {\n  /** constructor(prefix: String, uri: String)\n   *\n   * Creates a Namespace object according to the values of the prefixValue and uriValue parameters.\n   * This constructor requires both parameters.\n   *\n   * The value of the prefixValue parameter is assigned to the prefix property as follows:\n   *\n   * * If undefined is passed, prefix is set to undefined.\n   * * If the value is a valid XML name, as determined by the isXMLName() function, it is converted to a string and assigned to the prefix property.\n   * * If the value is not a valid XML name, the prefix property is set to undefined.\n   *\n   * The value of the uriValue parameter is assigned to the uri property as follows:\n   *\n   * * If a QName object is passed, the uri property is set to the value of the QName object's uri property.\n   * * Otherwise, the uriValue parameter is converted to a string and assigned to the uri property.\n  */\n  constructor(\n    public readonly prefix: undefined | string,\n    public readonly uri: AS3_QName | string\n  ) {\n    if (uri instanceof AS3_QName) uri = uri.uri + '';\n  }\n\n  /** Namespace(prefixValue:*, uriValue:*)\n   * \n   * Creates a Namespace object according to the values of the prefixValue and uriValue parameters.\n   * This constructor requires both parameters.\n   *\n   * The value of the prefixValue parameter is assigned to the prefix property as follows:\n   *\n   * * If undefined is passed, prefix is set to undefined.\n   * * If the value is a valid XML name, as determined by the isXMLName() function, it is converted to a string and assigned to the prefix property.\n   * If the value is not a valid XML name, the prefix property is set to undefined.\n   * The value of the uriValue parameter is assigned to the uri property as follows:\n   *\n   * * If a QName object is passed, the uri property is set to the value of the QName object's uri property.\n   * * Otherwise, the uriValue parameter is converted to a string and assigned to the uri property.\n   *\n   * Namespace(uriValue:*)\n   *\n   * Creates a Namespace object.\n   * The values assigned to the uri and prefix properties of the new Namespace object depend on the type of value passed for the uriValue parameter:\n   * \n   * * If no value is passed, the prefix and uri properties are set to an empty string.\n   * * If the value is a Namespace object, a copy of the object is created.\n   * * If the value is a QName object, the uri property is set to the uri property of the QName object.\n  */\n  Namespace(...args: [AS3_QName | string] | [undefined | string, AS3_QName | string]) {\n    let prefix: typeof args[0] = args[0];\n    let uri: typeof args[1] = args?.[1];\n\n    if (prefix == void 0) prefix = void 0;\n    else if (args.length === 2 && !AS3_XMLModule.isXMLName(prefix as string)) prefix = void 0;\n\n    if (uri instanceof AS3_QName)\n      uri = uri.uri + '';\n\n    return new AS3_XMLNamespace(prefix!.toString(), uri!)\n  }\n\n  /** toString():String\n   * \n   * Equivalent to the Namespace.uri property.\n   * * Namespace\n  */\n  toString(): string {\n    return this.uri.toString() || ''\n  }\n}\n\n\n/** An AS3-Standard-Like XML QName\n * \n * QName objects represent qualified names of XML elements and attributes.\n * Each QName object has a local name and a namespace Uniform Resource Identifier (URI).\n * When the value of the namespace URI is null, the QName object matches any namespace.\n * Use the QName constructor to create a new QName object that is either a copy of another QName object or a new QName object with a uri from a Namespace object and a localName from a QName object.\n * Methods specific to E4X can use QName objects interchangeably with strings.\n * E4X methods are in the QName, Namespace, XML, and XMLList classes.\n * These E4X methods, which take a string, can also take a QName object.\n * This interchangeability is how namespace support works with, for example, the XML.child() method.\n *\n * The QName class (along with the XML, XMLList, and Namespace classes) implements powerful XML-handling standards defined in ECMAScript for XML (E4X) specification (ECMA-357 edition 2).\n *\n * A qualified identifier evaluates to a QName object.\n * If the QName object of an XML element is specified without identifying a namespace, the uri property of the associated QName object is set to the global default namespace.\n * If the QName object of an XML attribute is specified without identifying a namespace, the uri property is set to an empty string.\n */\nclass AS3_QName {\n  readonly #localName: string;\n  readonly #uri: string | null;\n\n  get localName(): string {\n    return this.#localName;\n  }\n\n  get uri(): string | null {\n    return this.#uri;\n  }\n\n  /** QName(qname:QName)\n   *\n   * Creates a QName object that is a copy of another QName object.\n   * If the parameter passed to the constructor is a QName object, a copy of the QName object is created.\n   * If the parameter is not a QName object, the parameter is converted to a string and assigned to the localName property of the new QName instance.\n   * If the parameter is undefined or unspecified, a new QName object is created with the localName property set to the empty string.\n   *\n   * QName(uri:Namespace, localName:QName)\n   *\n   * Creates a QName object with a URI from a Namespace object and a localName from a QName object.\n   * If either parameter is not the expected data type, the parameter is converted to a string and assigned to the corresponding property of the new QName object.\n   * For example, if both parameters are strings, a new QName object is returned with a uri property set to the first parameter and a localName property set to the second parameter.\n   * In other words, the following permutations, along with many others, are valid forms of the constructor:\n   *\n   * * QName (uri:Namespace, localName:String);\n   * * QName (uri:String, localName: QName);\n   * * QName (uri:String, localName: String);\n   * If you pass null for the uri parameter, the uri property of the new QName object is set to null.\n  */\n  constructor(...args: [string | AS3_XMLNamespace | null, string | AS3_QName] | [AS3_QName]) {\n    var localName: any, uri: any;\n\n    if (args.length === 1 && args[0] instanceof AS3_QName)\n      [{ localName, uri }] = args\n\n    else if (args.length === 2) {\n      let [arg0, arg1] = args;\n\n      if (typeof arg0 === \"string\")\n        uri = arg0;\n      else if (arg0 instanceof AS3_XMLNamespace)\n        uri = arg0.uri;\n      else\n        uri = null\n\n      if (typeof arg1 === \"string\")\n        localName = arg1;\n      else\n        localName = arg1.localName;\n    }\n\n    else throw new Error(\"Invalid arguments\")\n\n    this.#localName = localName;\n    this.#uri = uri;\n  }\n\n  /** QName(qname:QName)\n   *\n   * Creates a QName object that is a copy of another QName object.\n   * * QName\n   *\n   * QName(uri:Namespace, localName:QName)\n   *\n   * Creates a QName object with a URI from a Namespace object and a localName from a QName object.\n   * * QName\n  */\n  QName(...args: [AS3_QName] | [AS3_XMLNamespace, AS3_QName]) {\n    return new AS3_QName(...args);\n  }\n\n  /** toString():String\n   *\n   * Returns a string composed of the URI, and the local name for the QName object, separated by \"::\".\n   *\n   * The format depends on the uri property of the QName object:\n   *\n   * ```\n   * If uri == \"\"\n   *     toString returns localName\n   *   else if uri == null\n   *     toString returns *::localName\n   *   else\n   *     toString returns uri::localName\n   * ```\n  */\n  toString(): string {\n    if (this.#uri == \"\")\n      return this.#localName;\n    else if (this.#uri == null)\n      return \"*::\" + this.#localName;\n    else\n      return this.#uri + \"::\" + this.#localName;\n  }\n\n  /** valueOf():QName\n   *\n   * Returns the QName object.\n   * * QName\n  */\n  valueOf(): AS3_QName {\n    return this;\n  }\n\n}\n\n\n/** \n * The XMLNodeType class contains constants used with XMLNode.nodeType.\n * The values are defined by the NodeType enumeration in the W3C DOM Level 1 recommendation: http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html\n */\nclass AS2_XMLNodeType {\n  /** ELEMENT_NODE:uint = 1\n   * \n   * Specifies that the node is an element.\n   * This constant is used with XMLNode.nodeType.\n   * The value is defined by the NodeType enumeration in the W3C DOM Level 1 recommendation: http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html\n   */\n  static readonly ELEMENT_NODE = 1;\n\n  /** TEXT_NODE:uint = 3\n   *\n   * Specifies that the node is a text node.\n   * This constant is used with XMLNode.nodeType.\n   * The value is defined by the NodeType enumeration in the W3C DOM Level 1 recommendation: http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html\n   */\n  static readonly TEXT_NODE = 3;\n\n  // ---\n  // These are Nodetypes not defined on the AS2_XMLNodeType class.\n  // They are defined elsewhere, and can't be handled in XML, but this is bad practice.\n  // They can be found here instead, since there is no reason for not having these either.\n  // ---\n\n  static readonly ENTITY_REFERENCE_NODE = 5;\n  static readonly PROCESSING_INSTRUCTION_NODE = 7;\n  static readonly DOCUMENT_NODE = 9;\n  static readonly DOCUMENT_FRAGMENT_NODE = 11;\n}\n\n\n/** An AS2-Standard-Like XMLNode\n * \n * The XMLNode class represents the legacy XML object that was present in ActionScript 2.0 and that was renamed in ActionScript 3.0.\n * In ActionScript 3.0, consider using the new top-level XML class and related classes instead, which support E4X (ECMAScript for XML). The XMLNode class is present for backward compatibility.\n */\nclass AS2_XMLNode {\n  /** attributes:Object\n   * \n   * An object containing all of the attributes of the specified XMLNode instance.\n   * The XMLNode.attributes object contains one variable for each attribute of the XMLNode instance.\n   * Because these variables are defined as part of the object, they are generally referred to as properties of the object.\n   * The value of each attribute is stored in the corresponding property as a string.\n   * For example, if you have an attribute named color, you would retrieve that attribute's value by specifying color as the property name, as the following code shows:\n   * ```as\n   * \t var myColor:String = doc.firstChild.attributes.color\n   * ```\n   */\n  attributes: Record<string, string> = {}\n\n  // @important\n  /** childNodes:Array  [read-only]\n   * \n   * An array of the specified XMLNode object's children.\n   * Each element in the array is a reference to an XMLNode object that represents a child node.\n   * This is a read-only property and cannot be used to manipulate child nodes.\n   * Use the appendChild(), insertBefore(), and removeNode() methods to manipulate child nodes.\n   *\n   * This property is undefined for text nodes (nodeType == 3).\n   */\n  get childNodes(): Array<AS2_XMLNode> | undefined {\n    return this.#childNodes\n  }\n\n  #childNodes: Array<AS2_XMLNode> | undefined =\n    this.nodeType == 3 ? undefined : [];\n\n  /** firstChild:XMLNode  [read-only]\n   *\n   * Evaluates the specified XMLDocument object and references the first child in the parent node's child list.\n   * This property is null if the node does not have children.\n   * This property is undefined if the node is a text node.\n   * This is a read-only property and cannot be used to manipulate child nodes; use the appendChild(), insertBefore(), and removeNode() methods to manipulate child nodes.\n   */\n  get firstChild(): AS2_XMLNode | null | undefined {\n    return this.childNodes?.[0]\n  }\n\n  /** lastChild:XMLNode\n   * \n   * An XMLNode value that references the last child in the node's child list.\n   * The XMLNode.lastChild property is null if the node does not have children.\n   * This property cannot be used to manipulate child nodes; use the appendChild(), insertBefore(), and removeNode() methods to manipulate child nodes.\n   */\n  get lastChild(): AS2_XMLNode | null {\n    return this.childNodes?.[this.childNodes.length - 1] || null\n  }\n\n  /** localName:String  [read-only]\n   *\n   * The local name portion of the XML node's name.\n   * This is the element name without the namespace prefix. For example, the node <contact:mailbox/>bob@example.com</contact:mailbox> has the local name \"mailbox\", and the prefix \"contact\", which comprise the full element name \"contact.mailbox\".\n   *\n   * You can access the namespace prefix through the prefix property of the XML node object.\n   * The nodeName property returns the full name (including the prefix and the local name).\n   */\n  get localName(): string {\n    return this.#localName\n  }\n  #localName: string = ''\n\n  withLocalName(localName: string) {\n    if (this.#localName) throw new Error(\"Cannot change local name, this is Internal.\");\n    this.#localName = localName\n    return this\n  }\n\n  /** namespaceURI:String  [read-only]\n   * \n   * If the XML node has a prefix, namespaceURI is the value of the xmlns declaration for that prefix (the URI), which is typically called the namespace URI. The xmlns declaration is in the current node or in a node higher in the XML hierarchy.\n   *\n   * If the XML node does not have a prefix, the value of the namespaceURI property depends on whether there is a default namespace defined (as in xmlns=\"http://www.example.com/\").\n   * If there is a default namespace, the value of the namespaceURI property is the value of the default namespace.\n   * If there is no default namespace, the namespaceURI property for that node is an empty string (\"\").\n   *\n   * You can use the getNamespaceForPrefix() method to identify the namespace associated with a specific prefix.\n   * The namespaceURI property returns the prefix associated with the node name.\n   */\n  get namespaceURI(): string {\n    return this.prefix == null ? '' : this.prefix\n  }\n\n  /** nextSibling:XMLNode  [read-only]\n   * \n   * An XMLNode value that references the next sibling in the parent node's child list. This property is null if the node does not have a next sibling node.\n   * This property cannot be used to manipulate child nodes; use the appendChild(), insertBefore(), and removeNode() methods to manipulate child nodes.\n   */\n  get nextSibling(): AS2_XMLNode | null {\n    return this.parentNode?.childNodes?.[this.parentNode.childNodes.indexOf(this) + 1] || null\n  }\n\n  // @important\n  /** nodeName:String  [read-only]\n   *\n   * A string representing the node name of the XMLNode object.\n   *\n   * If the XMLNode object is an XML element (nodeType == 1), nodeName is the name of the tag that represents the node in the XML file.\n   *\n   * For example, TITLE is the nodeName of an HTML TITLE tag.\n   *\n   * If the XMLNode object is a text node (nodeType == 3), nodeName is null.\n   */\n  get nodeName(): string | null {\n    return this.nodeType == 1 ? this.localName : null\n  }\n\n  // @Todo\n  /** nodeType:uint  \n   *\n   * A nodeType constant value, either XMLNodeType.ELEMENT_NODE for an XML element or\n   * XMLNodeType.TEXT_NODE for a text node.\n   *\n   * The nodeType is a numeric value from the NodeType enumeration in the W3C DOM Level 1 recommendation: http://www.w3.org/TR/1998/REC-DOM-Level-1-19981001/level-one-core.html.\n   * The following table lists the values:\n   *\n   * Integer value\tDefined constant\n   * * 1\tELEMENT_NODE\n   * * 3\tTEXT_NODE\n   * * 5\tENTITY_REFERENCE_NODE\n   * * 7\tPROCESSING_INSTRUCTION_NODE\n   * * 9\tDOCUMENT_NODE\n   * * 11\tDOCUMENT_FRAGMENT_NODE\n   * \n   * In Flash Player, the built-in XMLNode class only supports XMLNodeType.ELEMENT_NODE and XMLNodeType.TEXT_NODE.\n   */\n  get nodeType() {\n    return this.#nodeType\n  }\n  #nodeType:\n    typeof AS2_XMLNodeType.ELEMENT_NODE\n    | typeof AS2_XMLNodeType.TEXT_NODE\n    = 1\n\n  /** nodeValue:String  \n   *\n   * The node value of the XMLDocument object.\n   * If the XMLDocument object is a text node, the nodeType is 3, and the nodeValue is the text of the node.\n   * If the XMLDocument object is an XML element (nodeType is 1), nodeValue is null and read-only.\n   */\n  get nodeValue(): string | null {\n    return this.#nodeType == 3 ? this.#nodeValue : null\n  }\n  #nodeValue: string | null = null\n\n  set nodeValue(value: string | null) {\n    if (this.#nodeType == 1) throw new Error(\"Invalid node type\")\n    this.#nodeValue = value\n  }\n\n  /** parentNode:XMLNode\n   *\n   * An XMLNode value that references the parent node of the specified XML object, or returns null if the node has no parent.\n   * This is a read-only property and cannot be used to manipulate child nodes; use the appendChild(), insertBefore(), and removeNode() methods to manipulate child nodes.\n   */\n  get parentNode(): AS2_XMLNode | null {\n    return this.#parentNode\n  }\n  #parentNode: AS2_XMLNode | null = null\n\n  /** prefix:String  [read-only]\n   *\n   * The prefix portion of the XML node name. For example, the node <contact:mailbox/>bob@example.com</contact:mailbox> prefix \"contact\" and the local name \"mailbox\", which comprise the full element name \"contact.mailbox\".\n   *\n   * The nodeName property of an XML node object returns the full name (including the prefix and the local name).\n   * You can access the local name portion of the element's name via the localName property.\n   */\n  get prefix(): string | null | undefined {\n    return this.nodeName?.split(':')[0]\n  }\n\n  /** previousSibling:XMLNode\n   * \n   * An XMLNode value that references the previous sibling in the parent node's child list.\n   * The property has a value of null if the node does not have a previous sibling node.\n   * This property cannot be used to manipulate child nodes; use the appendChild(), insertBefore(), and removeNode() methods to manipulate child nodes.\n   */\n  get previousSibling(): AS2_XMLNode | null | undefined {\n    return this.parentNode?.childNodes?.[this.parentNode.childNodes.indexOf(this) - 1]\n  }\n\n  /** XMLNode(type:uint, value:String)\n   *\n   * Creates a new XMLNode object. You must use the constructor to create an XMLNode object before you call any of the methods of the XMLNode class.\n   *\n   * Note: Use the createElement() and createTextNode() methods to add elements and text nodes to an XML document tree.\n   */\n  constructor(\n    type: XMLNodeTypes,\n    value?: string | null\n  ) {\n    this.#nodeType = type\n    this.#nodeValue = value || null\n  }\n\n  /** appendChild(node:XMLNode):void\n   * \n   * Appends the specified node to the XML object's child list.\n   * This method operates directly on the node referenced by the childNode parameter; it does not append a copy of the node. If the node to be appended already exists in another tree structure, appending the node to the new location will remove it from its current location.\n   * If the childNode parameter refers to a node that already exists in another XML tree structure, the appended child node is placed in the new tree structure after it is removed from its existing parent node.\n   */\n  appendChild(node: AS2_XMLNode): void {\n    if (this.nodeType == 3)\n      throw new Error(\"Invalid node type\")\n    if (this.#childNodes == undefined)\n      this.#childNodes = []\n    this.#childNodes.push(node)\n\n    let pn = node.#parentNode\n    if (pn == this) return;\n\n    if (pn != undefined)\n      pn.#removeChild(node)\n\n    node.#parentNode = this\n  }\n\n  #removeChild(node: AS2_XMLNode): void {\n    let i = this.#childNodes?.indexOf(node) || -1\n    if (i == -1) return;\n    this.#childNodes?.splice(i, 1)\n  }\n\n  /** cloneNode(deep:Boolean):XMLNode\n   * \n   * Constructs and returns a new XML node of the same type, name, value, and attributes as the specified XML object.\n   * If deep is set to true, all child nodes are recursively cloned, resulting in an exact copy of the original object's document tree.\n   *\n   * The clone of the node that is returned is no longer associated with the tree of the cloned item.\n   * Consequently, nextSibling, parentNode, and previousSibling all have a value of null.\n   * If the deep parameter is set to false, or the my_xml node has no child nodes, firstChild and lastChild are also null.\n   */\n  cloneNode(deep: boolean): AS2_XMLNode {\n    let node = new AS2_XMLNode(this.nodeType, this.#nodeValue)\n    if (deep && (this.#childNodes != undefined))\n      for (const child of this.#childNodes)\n        node.appendChild(child.cloneNode(deep))\n    return node\n  }\n\n  /** getNamespaceForPrefix(prefix:String):String\n   * \n   * Returns the namespace URI that is associated with the specified prefix for the node.\n   * To determine the URI, getPrefixForNamespace() searches up the XML hierarchy from the node, as necessary, and returns the namespace URI of the first xmlns declaration for the given prefix.\n   *\n   * If no namespace is defined for the specified prefix, the method returns null.\n   *\n   * If you specify an empty string (\"\") as the prefix and there is a default namespace defined for the node (as in xmlns=\"http://www.example.com/\"), the method returns that default namespace URI.\n   */\n  getNamespaceForPrefix(prefix: string): string | null {\n    if (prefix == '') return this.namespaceURI\n    let node: AS2_XMLNode | null = this\n    while (node != null) {\n      if (node.prefix == prefix)\n        return node.namespaceURI\n      node = node.parentNode\n    }\n    return null\n  }\n\n  /** hasChildNodes():Boolean\n   * \n   * Indicates whether the specified XMLNode object has child nodes.\n   * This property is true if the specified XMLNode object has child nodes; otherwise, it is false.\n   */\n  hasChildNodes(): boolean {\n    return this.#childNodes != undefined\n  }\n\n  /** insertBefore(node:XMLNode, before:XMLNode):void\n   *\n   * Inserts a new child node into the XML object's child list, before the beforeNode node.\n   * If the beforeNode parameter is undefined or null, the node is added using the appendChild() method.\n   * If beforeNode is not a child of my_xml, the insertion fails.\n   */\n  insertBefore(node: AS2_XMLNode, before: AS2_XMLNode | null): void {\n    if (this.nodeType == 3)\n      throw new Error(\"Invalid node type\")\n    if (this.#childNodes == undefined)\n      this.#childNodes = []\n\n    if (before == null)\n      this.appendChild(node)\n    else if (this.#childNodes.indexOf(before) == -1)\n      throw new Error(\"Invalid node\")\n    else\n      this.#childNodes.splice(this.#childNodes.indexOf(before), 0, node)\n  }\n\n  /** removeNode():void\n   * Removes the specified XML object from its parent.\n   * Also deletes all descendants of the node.\n   */\n  removeNode(): void {\n    if (this.#parentNode == null)\n      throw new Error(\"Invalid node\")\n\n    this.#parentNode.#childNodes?.splice(this.#parentNode.#childNodes.indexOf(this), 1)\n    this.#parentNode = null\n\n    if (this.#childNodes) for (const child of this.#childNodes)\n      child.removeNode()\n  }\n\n  /** toString():String \n   * Evaluates the specified XMLNode object, constructs a textual representation of the XML structure, including the node, children, and attributes, and returns the result as a string.\n   *\n   * For top-level XMLDocument objects (those created with the constructor), the XMLDocument.toString() method outputs the document's XML declaration (stored in the XMLDocument.xmlDecl property), followed by the document's DOCTYPE declaration (stored in the XMLDocument.docTypeDecl property), followed by the text representation of all XML nodes in the object.\n   * The XML declaration is not output if the XMLDocument.xmlDecl property is null. The DOCTYPE declaration is not output if the XMLDocument.docTypeDecl property is null.\n   */\n  toString(): string {\n    let str = ''\n    if (this.nodeType == 3)\n      return str += this.nodeValue\n\n    str += '<' + this.nodeName\n    if (this.nodeType == 1 && this.attributes != undefined)\n      for (const attr of Object.entries(this.attributes))\n        str += ` ${attr[0]}=\"${attr[1]}\"`\n\n    if (this.#childNodes == undefined)\n      return str += ' />';\n\n    str += '>'\n\n    for (const child of this.#childNodes)\n      str += child.toString()\n\n    str += '</' + this.nodeName + '>'\n\n    return str\n  }\n}\n\n\ntype DTDEntity = '&lt;' | '&gt;' | '&amp;' | '&apos;' | '&quot;'\ntype DTDEntRes = '<' | '>' | '&' | \"'\" | '\"'\n\ntype DTDAttrType =\n  'CDATA'\n  | 'ID'\n  | 'IDREF'\n  | 'IDREFS'\n  | 'NMTOKEN'\n  | 'NMTOKENS'\n  | 'ENTITY'\n  | 'ENTITIES'\n  | 'NOTATION'\n\nclass DTDMaker {\n  // PUBLIC \"http://www.ibm.com/example.dtd\" \"example.dtd\"\n  static SYSTEM(file: string) {\n    return `SYSTEM \"${file}\"`\n  }\n  readonly SYSTEM = DTDMaker.SYSTEM\n\n  static PUBLIC(uri: string, file: string) {\n    return `PUBLIC \"${uri}\" \"${file}\"`\n  }\n  readonly PUBLIC = DTDMaker.PUBLIC\n\n  static INTERNAL(blocks: string[]) {\n    return `[\\n${blocks.join('\\n')}\\n]`\n  }\n  readonly INTERNAL = DTDMaker.INTERNAL\n\n  static #entityMap: [DTDEntity, DTDEntRes][] = [\n    ['&lt;', '<'],\n    ['&gt;', '>'],\n    ['&amp;', '&'],\n    ['&apos;', \"'\"],\n    ['&quot;', '\"'],\n  ]\n\n  static parseEntity(kind: DTDEntity): DTDEntRes | undefined {\n    return this.#entityMap.find(e => e[0] == kind)?.[1]\n  }\n  readonly parsenEntity = DTDMaker.parseEntity\n\n  static getEntity(kind: DTDEntRes): DTDEntity | undefined {\n    return this.#entityMap.find(e => e[1] == kind)?.[0]\n  }\n  readonly getEntity = DTDMaker.getEntity\n\n  static DTDMixedSelect = class DTDMixedSelect extends Array {\n    constructor(arr: string[]) {\n      super(arr.length)\n      this.fill(void 0 as any)\n      this.map((_, i) => arr[i])\n    }\n\n    toString(): string {\n      return this.join('|')\n    }\n  }\n  readonly DTDMixedSelect = DTDMaker.DTDMixedSelect\n\n  static makeMixedSelect(arr: string[]) {\n    return new this.DTDMixedSelect(arr)\n  }\n  readonly makeMixedSelect = DTDMaker.makeMixedSelect\n\n  static makeElement(name: string, cont: string | string[] | DTDMaker['DTDMixedSelect'] | 'EMPTY' | 'ANY', isCategory = true) {\n    if (cont == 'EMPTY') isCategory = true\n    else if (cont == '#PCDATA') isCategory = false\n    else if (Array.isArray(cont)) isCategory = true\n\n    cont = cont.toString()\n    return `<!ELEMENT ${name} ${isCategory ? `(${cont})` : cont}>`\n  }\n  readonly makeElement = DTDMaker.makeElement\n\n  static makeAttribute(elementName: string, name: string, type: string, def: DTDAttrType | DTDMaker['DTDMixedSelect'], isRequired = false, isImplied = false, isFixed = false) {\n    let str = `<!ATTLIST ${elementName} ${name} ${type}`\n    if (isRequired) str += ' #REQUIRED'\n    if (isImplied) str += ' #IMPLIED'\n    if (isFixed) str += ' #FIXED'\n\n    if (type == 'IDREFS' || type == 'NMTOKENS') {\n      str += ' ('\n      str += def.toString()\n      str += ')'\n    } else {\n      str += ` ${def}`\n    }\n\n    str += '>'\n\n    return str\n  }\n  readonly makeAttribute = DTDMaker.makeAttribute\n\n  static makeEntity(name: string, value: string, externalNS: string) {\n    return `<!ENTITY ${name} ${externalNS} \"${value}\">`\n  }\n  readonly makeEntity = DTDMaker.makeEntity\n\n  static makeCDATA(value: string) {\n    return `<![CDATA[${value}]]`\n  }\n  readonly makeCDATA = DTDMaker.makeCDATA\n\n}\n\n\n/** An AS2-Standard-Like XMLDocument\n * \n * The XMLDocument class represents the legacy XML object that was present in ActionScript 2.0.\n * It was renamed in ActionScript 3.0 to XMLDocument to avoid name conflicts with the new XML class in ActionScript 3.0.\n * In ActionScript 3.0, it is recommended that you use the new XML class and related classes, which support E4X (ECMAScript for XML).\n * The XMLDocument class, as well as XMLNode and XMLNodeType, are present for backward compatibility. The functionality for loading XML documents can now be found in the URLLoader class. \n */\nclass AS2_XMLDocument extends AS2_XMLNode {\n\n  /** \n   * Specifies information about the XML document's DOCTYPE declaration.\n   * After the XML text has been parsed into an XMLDocument object, the XMLDocument.docTypeDecl property of the XMLDocument object is set to the text of the XML document's DOCTYPE declaration (for example, <!DOCTYPE greeting SYSTEM \"hello.dtd\">).\n   * This property is set using a string representation of the DOCTYPE declaration, not an XMLNode object.\n   *\n   * The legacy ActionScript XML parser is not a validating parser. The DOCTYPE declaration is read by the parser and stored in the XMLDocument.docTypeDecl property, but no DTD validation is performed.\n   *\n   * If no DOCTYPE declaration was encountered during a parse operation, the XMLDocument.docTypeDecl property is set to null. The XML.toString() method outputs the contents of XML.docTypeDecl immediately after the XML declaration stored in XML.xmlDecl, and before any other text in the XML object. If XMLDocument.docTypeDecl is null, no DOCTYPE declaration is output.\n   */\n  docTypeDecl = null\n\n  /**\n   * An Object containing the nodes of the XML that have an id attribute assigned.\n   * The names of the properties of the object (each containing a node) match the values of the id attributes.\n   *\n   * Consider the following XMLDocument object:\n   * ```xml\n   * <employee id='41'>\n   *   <name>John Doe</name>\n   *   <address>601 Townsend St.</address>\n   * </employee>\n   *\n   * <employee id='42'>\n   *   <name>Jane Q. Public</name>\n   * </employee>\n   * <department id=\"IT\">\n   *   Information Technology\n   * </department>\n   * ```\n   * In this example, the idMap property for this XMLDocument object is an Object with three properties: 41, 42, and IT. Each of these properties is an XMLNode that has the matching id value. For example, the IT property of the idMap object is this node:\n   *\n   * ```xml\n   * <department id=\"IT\">\n   *   Information Technology\n   * </department>\n   * ```\n   * \n   * You must use the parseXML() method on the XMLDocument object for the idMap property to be instantiated.\n   *\n   * If there is more than one XMLNode with the same id value, the matching property of the idNode object is that of the last node parsed. For example:\n   *\n   * ```as\n   * var x1:XML = new XMLDocument(\"<a id='1'><b id='2' /><c id='1' /></a>\");\n   * x2 = new XMLDocument();\n   * x2.parseXML(x1);\n   * trace(x2.idMap['1']);\n   *\n   * This will output the <c> node:\n   * ```xml\n   *   <c id='1' />\n   * ```\n   */\n  idMap = new Map<string, AS2_XMLNode>\n\n  /** ignoreWhite:Boolean = false\n   *\n   * When set to true, text nodes that contain only white space are discarded during the parsing process.\n   * Text nodes with leading or trailing white space are unaffected. The default setting is false.\n   *\n   * You can set the ignoreWhite property for individual XMLDocument objects, as the following code shows:\n   * ```as\n   * my_xml.ignoreWhite = true;\n   * ```\n   */\n  ignoreWhite = false\n\n  /** xmlDecl:Object = null\n   *\n   * A string that specifies information about a document's XML declaration.\n   * After the XML document is parsed into an XMLDocument object, this property is set to the text of the document's XML declaration.\n   * This property is set using a string representation of the XML declaration, not an XMLNode object.\n   * If no XML declaration is encountered during a parse operation, the property is set to null.\n   * The XMLDocument.toString() method outputs the contents of the XML.xmlDecl property before any other text in the XML object.\n   * If the XML.xmlDecl property contains null, no XML declaration is output.\n   */\n  xmlDecl = null\n\n  /**\n\n  /** public function XMLDocument(source:String = null)\n   *\n   * Creates a new XMLDocument object.\n   * You must use the constructor to create an XMLDocument object before you call any of the methods of the XMLDocument class.\n   *\n   * Note: Use the createElement() and createTextNode() methods to add elements and text nodes to an XML document tree.\n   */\n  constructor(source: string | null = null) {\n    super(AS2_XMLNodeType.DOCUMENT_NODE as XMLNodeTypes, source)\n  }\n\n  /** createElement(name:String):XMLNode\n   * \n   * Creates a new XMLNode object with the name specified in the parameter.\n   * The new node initially has no parent, no children, and no siblings.\n   * The method returns a reference to the newly created XMLNode object that represents the element.\n   * This method and the XMLDocument.createTextNode() method are the constructor methods for creating nodes for an XMLDocument object.\n   */\n  createElement(name: string): AS2_XMLNode {\n    return new AS2_XMLNode(1).withLocalName(name);\n  }\n\n  /** createTextNode(text:String):XMLNode\n   *\n   * Creates a new XML text node with the specified text.\n   * The new node initially has no parent, and text nodes cannot have children or siblings.\n   * This method returns a reference to the XMLDocument object that represents the new text node.\n   * This method and the XMLDocument.createElement() method are the constructor methods for creating nodes for an XMLDocument object.\n   */\n  createTextNode(text: string): AS2_XMLNode {\n    return new AS2_XMLNode(3, text);\n  }\n\n  /** parseXML(source:String):void\n   *\n   * Parses the XML text specified in the value parameter and populates the specified XMLDocument object with the resulting XML tree.\n   * Any existing trees in the XMLDocument object are discarded.\n   */\n  parseXML(source: string, version = 1.0, enc = 'UTF-8', standalone = 'no', entrytag = 'data', dtd?: string, nativeParser = true): void {\n\n    // @TODO: Implement native Parser\n    nativeParser ||= false\n\n    let args = [version, enc, standalone, entrytag, dtd]\n\n    if (nativeParser)\n      this.#parseXMLNative(source, ...args)\n\n    if (runtime == 'node') this.#parseJSNode(source, ...args)\n    else this.#parseJSWeb(source, ...args)\n  }\n\n  #parseJSNode(source: string, ...args: any[]) {\n    // Current RT:  npm i fast-xml-parser\n\n    // @ts-ignore\n    try { require }\n    catch (e) { throw new Error(e + 'Require is not defined!') }\n\n    // @ts-ignore\n    const { XMLParser, XMLBuilder, XMLValidator } = require('fast-xml-parser')\n\n    const parser = new XMLParser();\n    parser.parse(source);\n  }\n\n  #parseJSWeb(source: string, ...args: any[]) {\n    let decl = this.#makeDecl(...args)\n    let dom = new DOMParser()\n    let doc = dom.parseFromString(decl + source, 'text/xml')\n  }\n\n  #makeDecl(version = 1.0, enc = 'UTF-8', standalone = 'no', entrytag = 'data', DTD?: string) {\n    return `<?xml version=\"${version}\" encoding=\"${enc}\" standalone=\"${standalone}\"?>`\n      + `\\n<!DOCTYPE ${entrytag} ${DTD}>`\n  }\n\n  #parseXMLNative(source: string, ...args: any[]) {\n\n  }\n\n  /** toString():String\n   *\n   * Returns a string representation of the XML object.\n   */\n  toString(): string {\n    return '@ TODO'\n  }\n}\n\nexport class AS3_XML {\n  // readonly #isProxy: boolean = true;\n  // readonly #localName: Object;\n  // readonly #parent: Object;\n  // readonly #children: AS3_XMLList;\n  // readonly #attributes: AS3_XMLList;\n  // readonly #nodeKind: string;\n  // readonly #cdata: boolean;\n\n  // readonly #string: string;\n  // readonly #stringInvalidated: boolean;\n\n  // readonly #xmlString: string;\n  // readonly #xmlStringInvalidated: boolean;\n\n  // readonly #xmlNode: AS2_XMLNode;\n\n  constructor(...any: any[]) { } // @TODO: Implement\n  length(): any { }\n}\n\nexport class AS3_XMLList {\n  constructor(...any: any[]) { } // @TODO: Implement\n  length(): any { }\n}\n\n\n// ---\n\n\nclass AS3_XMLModule {\n  static AS3_XMLModule = this\n  AS3_XMLModule = AS3_XMLModule\n\n  XMLDocument = AS2_XMLDocument\n  XMLNode = AS2_XMLNode\n  XMLNodeType = AS2_XMLNodeType\n  XMLListClass = AS3_XMLList\n  XMLClass = AS3_XML\n  DTDMaker = DTDMaker\n\n  XMLDefaultsClass = XMLModuleDefaultsClass\n  XMLDefaults = new XMLModuleDefaultsClass;\n\n  static isXMLName(name: string): boolean {\n    return !!name?.match?.(/^[a-zA-Z0-9_-]+$/)\n  }\n  isXMLName = AS3_XMLModule.isXMLName\n\n  /** XML(expression:Object):XML\n   *\n   * Converts an object to an XML object.\n   *\n   * The following table describes return values for various input types.\n   *\n   * Parameter | Type\tReturn Value\n   * * Boolean | Value is first converted to a string, then converted to an XML object.\n   * * Null | A runtime error occurs (TypeError exception).\n   * * Number | Value is first converted to a string, then converted to an XML object.\n   * * Object | Converts to XML only if the value is a String, Number or Boolean value. Otherwise a runtime error occurs (TypeError exception).\n   * * String | Value is converted to XML.\n   * * Undefined | A runtime error occurs (TypeError exception).\n   * * XML | Input value is returned unchanged.\n   * * XMLList | Returns an XML object only if the XMLList object contains only one property of type XML. Otherwise a runtime error occurs (TypeError exception).\n  */\n  static XML(xml: XMLArgs) {\n    if (xml instanceof AS3_XML)\n      return xml;\n    if (xml instanceof AS3_XMLList)\n      // if (xml.length() == 1) return new AS3_XML(xml.nodes[0]); // @Todo\n      if (xml.length() == 1) { }\n      else throw new Error(\"XMLList must contain only one property of type XML\");\n\n    if (typeof xml === \"boolean\" || typeof xml === \"number\")\n      return new AS3_XML(xml.toString());\n    if (typeof xml === \"string\")\n      return new AS3_XML(xml);\n    if (xml === undefined)\n      throw new TypeError(\"Undefined\");\n    throw new TypeError(\"Invalid argument\");\n  }\n  XML = AS3_XMLModule.XML\n\n  /**\tXMLList(expression:Object):XMLList\n   * \n   * Converts an object to an XMLList object.\n   *\n   * The following table describes return values for various input types.\n   *\n   * Parameter Type |\tReturn Value\n   * * Boolean | Value is first converted to a string, then converted to an XMLList object.\n   * * Null | A runtime error occurs (TypeError exception).\n   * * Number | Value is first converted to a string, then converted to an XMLList object.\n   * * Object | Converts to XMLList only if the value is a String, Number or Boolean value. Otherwise a runtime error occurs (TypeError exception).\n   * * String | Value is converted to an XMLList object.\n   * * Undefined | A runtime error occurs (TypeError exception).\n   * * XML | Value is converted to an XMLList object.\n   * * XMLList | Input value is returned unchanged.\n  */\n  static XMLList(xml: XMLArgs) {\n    if (xml instanceof AS3_XMLList)\n      return xml;\n    if (typeof xml === \"boolean\" || typeof xml === \"number\")\n      return new AS3_XMLList(xml.toString());\n    if (typeof xml === \"string\")\n      return new AS3_XMLList(xml);\n    if (xml === undefined)\n      throw new TypeError(\"Undefined\");\n    throw new TypeError(\"Invalid argument\");\n  }\n  XMLList = AS3_XMLModule.XMLList\n}\n\n\n// ---\n\n\n// @ Export\nexport const ASXML = new AS3_XMLModule;\n\nif (globalThis?.window)\n  (globalThis.window as any).ASXML = ASXML","import runtime from './getRuntime'\n\nimport * as flash from './flash'\n// import * as air from './air'\n\nconst eobj = {\n  flash,\n  // air\n}\n\nexport default eobj\n\nif (runtime == 'web') {\n  Object.assign(globalThis, eobj)\n  Object.assign(window, eobj)\n  Object.assign(document, eobj)\n}\nelse if (runtime == 'node') try {\n  module.exports = eobj\n} catch { }"],"mappings":"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","names":["require_util","__commonJSMin","exports","nameStartChar","nameChar","nameRegexp","regexName","getAllMatches","string","regex","matches","match","allmatches","len","index","isName","v","obj","target","a","arrayMode","keys","require_validator","__commonJSMin","exports","util","defaultOptions","xmlData","options","tags","tagFound","reachedRoot","readPI","tagStartPos","readCommentAndCDATA","closingTag","tagName","validateTagName","msg","getErrorObject","getLineNumberForPosition","result","readAttributeStr","attrStr","attrStrStart","isValid","validateAttributeString","otg","openPos","afterAmp","validateAmpersand","isWhiteSpace","t","char","i","start","tagname","angleBracketsCount","doubleQuote","singleQuote","startChar","tagClosed","validAttrStrRegxp","matches","attrNames","getPositionFromMatch","attrName","validateAttrName","validateNumberAmpersand","re","count","code","message","lineNumber","index","lines","match","require_OptionsBuilder","__commonJSMin","exports","defaultOptions","tagName","val","attrName","jPath","attrs","buildOptions","options","require_xmlNode","__commonJSMin","exports","module","XmlNode","tagname","key","val","node","require_DocTypeReader","__commonJSMin","exports","module","util","readDocType","xmlData","i","entities","angleBracketsCount","hasBody","comment","exp","isEntity","readEntityExp","validateEntityName","isElement","isAttlist","isNotation","isComment","entityName","startChar","val","name","require_strnum","__commonJSMin","exports","module","hexRegex","numRegex","consider","toNumber","str","options","trimmedStr","match","sign","leadingZeros","numTrimmedByZeros","trimZeros","eNotation","num","numStr","require_OrderedObjParser","__commonJSMin","exports","module","util","xmlNode","readDocType","toNumber","OrderedObjParser","options","_","str","addExternalEntities","parseXml","parseTextData","resolveNameSpace","buildAttributesMap","isItStopNode","replaceEntitiesValue","readStopNodeData","saveTextToParentTag","addChild","externalEntities","entKeys","i","ent","val","tagName","jPath","dontTrim","hasAttributes","isLeafNode","escapeEntities","newval","parseValue","tagname","tags","prefix","attrsRegx","attrStr","matches","len","attrs","attrName","oldVal","aName","newVal","attrCollection","xmlData","xmlObj","currentNode","textData","closeIndex","findClosingIndex","colonIndex","lastTagName","propIndex","tagData","readTagExp","childNode","endIndex","comment","result","tagExp","rawTagName","attrExpPresent","lastTag","tagContent","entityName","entity","stopNodes","currentTagName","allNodesExp","stopNodePath","stopNodeExp","tagExpWithClosingIndex","closingChar","attrBoundary","index","ch","errMsg","closingIndex","removeNSPrefix","separatorIndex","startIndex","openTagCount","shouldParse","require_node2json","__commonJSMin","exports","prettify","node","options","compress","arr","jPath","text","compressedObj","tagObj","property","propName","newJpath","val","isLeaf","isLeafTag","assignAttributes","obj","keys","i","key","attrMap","jpath","len","atrrName","textNodeName","propCount","require_XMLParser","__commonJSMin","exports","module","buildOptions","OrderedObjParser","prettify","validator","XMLParser","options","xmlData","validationOption","result","orderedObjParser","orderedResult","key","value","require_orderedJs2Xml","__commonJSMin","exports","module","EOL","toXml","jArray","options","indentation","arrToStr","arr","jPath","xmlStr","isPreviousElementTag","i","tagObj","tagName","propName","newJPath","tagText","isStopNode","replaceEntitiesValue","attStr","attr_to_str","tempInd","piTextNodeName","newIdentation","tagStart","tagValue","obj","keys","key","attrMap","attrStr","attr","attrVal","index","textValue","entity","require_json2xml","__commonJSMin","exports","module","buildFromOrderedJs","defaultOptions","key","a","attrName","Builder","options","isAttribute","processTextOrObjNode","indentate","jObj","level","attrStr","val","attr","newval","arrLen","listTagVal","j","item","Ks","L","object","result","tagEndExp","piClosingChar","closeTag","textValue","i","entity","name","require_fxp","__commonJSMin","exports","module","validator","XMLParser","XMLBuilder","Env","is","v","check","m","getRuntime_default","flash_exports","__export","AS3_XML","AS3_XMLList","ASXML","AS_EventDispatcher","AS_System","AS_EventDispatcher","type","listener","useCapture","priority","useWeakReference","listeners","index","item","eventListener","event","eventListeners","derefListener","filterListeners","b","fxcommand","command","args","formattedArgs","arg","allowScale","toggleMenu","trapAllKeys","url","params","gt","allow","show","ce","trap","ApplicationDomain","_ApplicationDomain","#parentDomain","#defMap","parentDomain","source","name","Capabilities","IME","IMEConversionMode","LoaderContext","AS_MessageChannelState","AS_MessageChannel","AS_EventDispatcher","#state","#buffer","#view","#byteOffset","#byteLength","#isClosed","buffer","byteOffset","byteLength","#initializeChannel","AS_MessageChannelState","Security","SecurityDomain","SecurityPanel","System","AS_System","fxcommand","ApplicationDomain","Capabilities","IME","IMEConversionMode","LoaderContext","AS_MessageChannel","AS_MessageChannelState","Security","SecurityDomain","SecurityPanel","System","XMLModuleDefaultsClass","_XMLModuleDefaultsClass","AS2_XMLNodeType","AS2_XMLNode","_AS2_XMLNode","#childNodes","#localName","localName","#nodeType","#nodeValue","value","#parentNode","type","node","pn","#removeChild","i","deep","child","prefix","before","str","attr","DTDMaker","_DTDMaker","file","uri","blocks","#entityMap","kind","e","arr","_","name","cont","isCategory","elementName","def","isRequired","isImplied","isFixed","externalNS","AS2_XMLDocument","source","text","version","enc","standalone","entrytag","dtd","nativeParser","args","#parseXMLNative","getRuntime_default","#parseJSNode","#parseJSWeb","XMLParser","XMLBuilder","XMLValidator","decl","#makeDecl","doc","DTD","AS3_XML","any","AS3_XMLList","AS3_XMLModule","_AS3_XMLModule","XMLModuleDefaultsClass","xml","ASXML","eobj","flash_exports","src_default","getRuntime_default"]}