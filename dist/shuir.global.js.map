{"version":3,"sources":["../src/cst.ts","../src/operators.ts","../src/tokenize.ts","../src/build.ts","../src/evaluatePostfixShunted.ts","../src/shuir.ts"],"sourcesContent":["enum TokenType {\n  Number,\n  Operator,\n\n  LeftParen,\n  RightParen,\n  LeftBracket,\n  RightBracket,\n  LeftBrace,\n  RightBrace,\n\n  String,\n  HexNumStr,\n  BinNumStr,\n  OctNumStr,\n\n  Vector,\n  List,\n\n  Unknown,\n  EOF\n}\n\nenum StackType {\n  Number,\n  String,\n  Vector,\n  List,\n  Unknown\n}\n\nclass Token {\n  constructor(\n    public type: TokenType,\n    public value: string\n  ) { }\n}\n\nexport { TokenType, StackType, Token }","type OperatorKey = '^' | '*' | '/' | '+' | '-';\n\nconst operators: {\n  [key in OperatorKey]: { precedence: number, associativity: 'Left' | 'Right' }\n} = {\n  '^': { precedence: 4, associativity: 'Right' },\n  '*': { precedence: 3, associativity: 'Left' },\n  '/': { precedence: 3, associativity: 'Left' },\n  '+': { precedence: 2, associativity: 'Left' },\n  '-': { precedence: 2, associativity: 'Left' },\n};\n\nexport { operators }\nexport { type OperatorKey }","import { Token, TokenType } from './cst';\n\nfunction tokenize(expression: string): Token[] {\n  const tokens: Token[] = [];\n  const length = expression.length;\n  let i = 0;\n\n  const get = (_i = i) => expression[_i];\n  const look = (_i = 1) => get(expression.length - 1 - _i);\n  const peek = (_i = 1) => get(expression.length);\n  const peekI = (_i = 1) => get(i + _i);\n\n  const pushToken = (type: TokenType, value: string) => tokens.push(new Token(type, value));\n  const pushChar = (type: TokenType) => pushToken(type, expression[i]);\n\n  while (i < length) {\n    const char = expression[i];\n\n    if (/\\d/.test(char)) {\n      // Handle numbers\n      let numStr = char;\n      while (i + 1 < length && (/\\d/.test(peekI()) || (peekI() === '.' && !numStr.includes('.')))) {\n        numStr += get(++i);\n      }\n      pushToken(TokenType.Number, numStr);\n    }\n    else if (/[+\\-*/^]/.test(char)) {\n      // Handle operators\n      pushChar(TokenType.Operator);\n    }\n    else if (char === '(') {\n      // Handle left parenthesis\n      pushChar(TokenType.LeftParen);\n    }\n    else if (char === ')') {\n      // Handle right parenthesis\n      pushChar(TokenType.RightParen);\n    }\n    else if (/\\s/.test(char)) {\n      // Ignore whitespace\n    }\n    else if (/0x[0-9A-Fa-f]+/.test(char + peek(1))) {\n      // Handle hexadecimal numbers\n      let hexStr = '';\n      while (i < length && /[0-9A-Fa-f]/.test(expression[i + (hexStr.length > 0 ? 0 : 1)])) {\n        hexStr += get(i++);\n      }\n      // pushToken(TokenType.Number, parseInt(hexStr, 16).toString())\n      pushToken(TokenType.HexNumStr, hexStr);\n    }\n    else if (/0b[01]+/.test(char + peek(1))) {\n      // Handle binary numbers\n      let binStr = '';\n      while (i < length && /[01]/.test(expression[i + (binStr.length > 0 ? 0 : 1)])) {\n        binStr += get(i++);\n      }\n      // pushToken(TokenType.Number, parseInt(binStr, 2).toString())\n      pushToken(TokenType.BinNumStr, binStr);\n    }\n    else if (/0o[0-7]+/.test(char + peek(1))) {\n      // Handle octal numbers\n      let octStr = '';\n      while (i < length && /[0-7]/.test(expression[i + (octStr.length > 0 ? 0 : 1)])) {\n        octStr += get(i++);\n      }\n      // pushToken(TokenType.Number, parseInt(octStr, 8).toString())\n      pushToken(TokenType.OctNumStr, octStr);\n    }\n    else if (char === '\"' || char === \"'\" || char === \"`\") {\n      let str = '';\n      while (i < length && (\n        char !== expression[i] ||\n        (char === expression[i] && look() !== char) ||\n        (char === expression[i] && look() === char && peek() === char))) {\n        str += get(i++);\n      }\n      pushToken(TokenType.String, str || char + char);\n    }\n    else {\n      throw new Error(`Unknown character: ${char}`);\n    }\n\n    i++;\n  }\n\n  pushToken(TokenType.EOF, '');\n\n  return tokens;\n}\n\nexport { tokenize }","import { Token, TokenType, StackType } from './cst';\nimport { operators, OperatorKey } from './operators';\nimport { tokenize } from './tokenize';\n\nfunction build(expression: string) {\n  const tokens = tokenize(expression);\n  const outputQueue: Token[] = [];\n  const operatorStack: Token[] = [];\n\n  var stackType = StackType.Unknown;\n  const stateIs = (stacktype: StackType) => stacktype === stackType;\n\n  function InvalExprErr(e?: string): Error {\n    return new Error('Invalid expression' + (e ? `: ${e}` : ''));\n  }\n\n  function isLeftAssociative(token: Token): boolean {\n    return operators[token.value as OperatorKey].associativity === 'Left';\n  }\n\n  function precedence(token: Token): number {\n    return operators[token.value as OperatorKey].precedence;\n  }\n\n  function peek(i = 1): Token {\n    return operatorStack[operatorStack.length - i];\n  }\n\n  function shuffle(token: Token): number {\n    return operatorStack.push(token);\n  }\n\n  function pop(): Token | undefined {\n    return operatorStack.pop();\n  }\n\n  function push(token: Token): number {\n    return outputQueue.push(token);\n  }\n\n  function pushPopNext(_i = 1): number {\n    let p = pop();\n    if (p)\n      return push(p);\n\n    else\n      throw InvalExprErr();\n  }\n\n  function is(token: { type: TokenType; }, typeToBe: TokenType) {\n    return token.type === typeToBe;\n  }\n\n  function isOperator(token: Token): boolean {\n    return is(token, TokenType.Operator);\n  }\n\n  function isNumber(token: Token): boolean {\n    return is(token, TokenType.Number);\n  }\n\n  function isLeftParen(token: Token): boolean {\n    return is(token, TokenType.LeftParen);\n  }\n\n  function isRightParen(token: Token): boolean {\n    return is(token, TokenType.RightParen);\n  }\n\n  function isLeftBracket(token: Token): boolean {\n    return is(token, TokenType.LeftBracket);\n  }\n\n  function isRightBracket(token: Token): boolean {\n    return is(token, TokenType.RightBracket);\n  }\n\n  function isLeftBrace(token: Token): boolean {\n    return is(token, TokenType.LeftBrace);\n  }\n\n  function isRightBrace(token: Token): boolean {\n    return is(token, TokenType.RightBrace);\n  }\n\n  function isString(token: Token): boolean {\n    return is(token, TokenType.String);\n  }\n\n  function isHexNumStr(token: Token): boolean {\n    return is(token, TokenType.HexNumStr);\n  }\n\n  function isBinNumStr(token: Token): boolean {\n    return is(token, TokenType.BinNumStr);\n  }\n\n  function isOctNumStr(token: Token): boolean {\n    return is(token, TokenType.OctNumStr);\n  }\n\n  function isVector(token: Token): boolean {\n    return is(token, TokenType.Vector);\n  }\n\n  function isList(token: Token): boolean {\n    return is(token, TokenType.List);\n  }\n\n  function isUnknown(token: Token): boolean {\n    return is(token, TokenType.Unknown);\n  }\n\n  function isEOF(token: Token): boolean {\n    return is(token, TokenType.EOF);\n  }\n\n  function isOperatorToken(token: Token): boolean | 0 {\n    return operatorStack.length &&\n      isOperator(peek()) &&\n      (\n        (isLeftAssociative(token!) && precedence(token!) <= precedence(peek())) ||\n        (!isLeftAssociative(token!) && precedence(token!) < precedence(peek()))\n      );\n  }\n\n  function isIterState() {\n    return stateIs(StackType.String) || stateIs(StackType.Vector) || stateIs(StackType.List);\n  }\n\n  function isNoState() {\n    return stateIs(StackType.Unknown);\n  }\n\n  function setState(type: StackType) {\n    stackType = type;\n  }\n\n  function End() {\n    while (operatorStack.length) {\n      pushPopNext();\n    }\n  }\n\n  function handleEncodedNumber(token: Token | undefined, radix: number | undefined) {\n    let num = parseInt(token!.value, radix);\n    pushToken(TokenType.Number, num);\n  }\n\n  function pushToken(type: TokenType, value: any) {\n    return push(new Token(type, value));\n  }\n\n  function handleBlock(type: TokenType) {\n    while (operatorStack.length &&\n      peek().type !== type) {\n      pushPopNext();\n    }\n    pop();\n  }\n\n  while (tokens.length) {\n    const token = tokens.shift();\n\n    if (isNumber(token!)) {\n      push(token!);\n      if (isNoState())\n        setState(StackType.Number);\n    }\n    else if (isString(token!)) {\n      if (!isIterState())\n        setState(StackType.String);\n      push(token!);\n    }\n\n    else if (isOperator(token!)) {\n      while (isOperatorToken(token!)) {\n        pushPopNext();\n      }\n      shuffle(token!);\n    }\n\n    else if (isLeftParen(token!) || isLeftBracket(token!) || isLeftBrace(token!)) {\n      shuffle(token!);\n    }\n\n\n    // We solve and then bind a number with this\n    else if (isHexNumStr(token!))\n      handleEncodedNumber(token, 16);\n    else if (isBinNumStr(token!))\n      handleEncodedNumber(token, 2);\n    else if (isOctNumStr(token!))\n      handleEncodedNumber(token, 8);\n\n    else if (isRightParen(token!))\n      handleBlock(TokenType.LeftParen);\n    else if (isRightBracket(token!))\n      handleBlock(TokenType.LeftBracket);\n    else if (isRightBrace(token!))\n      handleBlock(TokenType.LeftBrace);\n    else if (isEOF(token!))\n      End();\n  }\n\n  return outputQueue;\n}\n\nexport { build }","import { Token, TokenType, StackType } from './cst';\n\nfunction evaluatePostfixShunted(postfixTokens: Token[]) {\n  const stack: any[] = [];\n\n  var stackType = StackType.Unknown;\n\n  function stateIs(stacktype: StackType) {\n    return stacktype === stackType;\n  }\n\n  function isIterState() {\n    return stateIs(StackType.String) || stateIs(StackType.Vector) || stateIs(StackType.List);\n  }\n\n  function isNoState() {\n    return stateIs(StackType.Unknown);\n  }\n\n  function setState(type: StackType) {\n    stackType = type;\n  }\n\n  function handleCase(result: any, token: Token, a: number, b: number) {\n    switch (token.value) {\n      case '+':\n        result = a + b;\n        break;\n      case '-':\n        result = a - b;\n        break;\n      case '*':\n        result = a * b;\n        break;\n      case '/':\n        result = a / b;\n        break;\n      case '^':\n        result = Math.pow(a, b);\n        break;\n      default:\n        throw new Error('Unknown operator: ' + token.value);\n    }\n    return result;\n  }\n\n  postfixTokens.forEach((token) => {\n    switch (token.type) {\n      case TokenType.Number:\n        stack.push(parseFloat(token.value));\n        break;\n\n      case TokenType.Operator:\n        const b = stack.pop()!;\n        const a = stack.pop()!;\n\n        let result = handleCase(void 0, token, a, b);\n\n        stack.push(result);\n        break;\n\n      case TokenType.String:\n        stack.push(token.value);\n        if (isNoState())\n          setState(StackType.String);\n        break;\n\n      case TokenType.EOF:\n        break;\n\n      default:\n        throw new Error('Unexpected TokenType: ' + TokenType[token.type]);\n    }\n  });\n\n  // if (stack.length !== 1) throw new Error('Invalid postfix expression');\n  return stack.pop();\n}\n\nexport { evaluatePostfixShunted }","import { build } from './build';\nimport { evaluatePostfixShunted } from './evaluatePostfixShunted';\n\n// ShuntingYard\nfunction compile(expression: string) {\n  return evaluatePostfixShunted(build(expression))\n}\n\nexport { compile }\n\n// Example usage:\nconst expression = \"\";\nconsole.log(compile(expression)); // Should output: 3.0001220703125"],"mappings":"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","names":["TokenType","Token","type","value","operators","tokenize","expression","tokens","length","i","get","_i","look","peek","peekI","pushToken","type","value","Token","pushChar","char","numStr","hexStr","binStr","octStr","str","build","expression","tokens","tokenize","outputQueue","operatorStack","stackType","stateIs","stacktype","InvalExprErr","isLeftAssociative","token","operators","precedence","peek","i","shuffle","pop","push","pushPopNext","_i","p","is","typeToBe","isOperator","isNumber","isLeftParen","isRightParen","isLeftBracket","isRightBracket","isLeftBrace","isRightBrace","isString","isHexNumStr","isBinNumStr","isOctNumStr","isVector","isList","isUnknown","isEOF","isOperatorToken","isIterState","isNoState","setState","type","End","handleEncodedNumber","radix","num","pushToken","value","Token","handleBlock","evaluatePostfixShunted","postfixTokens","stack","stackType","stateIs","stacktype","isIterState","isNoState","setState","type","handleCase","result","token","a","b","TokenType","compile","expression","evaluatePostfixShunted","build","expression","compile"]}